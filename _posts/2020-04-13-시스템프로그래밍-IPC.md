---
title: "시스템프로그래밍-IPC"
category:
  - system programming
tag:
  - system programming
  - linux
toc: true
toc_sticky: true
---

# IPC(Inter-Process Communication)

- IPC : 프로세스 사이에서 통신을 가능케 하는 매커니즘의 통칭.
- 일반 파일, mmap, 세마포어, 공유 메모리, 메시지 큐, 파이프, 소켓 등의 모든 통신 기법이 IPC에 해당한다.
- 보통 IPC라고 하면 공유 메모리, 세마포어, 메시지 큐 3가지를 일컫는데, XSI방식과 POSIX방식으로 나눠진다.

# 공유 메모리 mmap

mmap (memory mapped I/O) : 장치나 파일을 메모리와 대응시키는 기법

- mmap의 권한 : 읽기, 쓰기, 실행 (rwx)
- mmap의 공유 방식 : 공유 메모리맵(shared mmap), 사설 메모리맵(private mmap)

```c
int fd = open("/tmp/myfile",O_RDWR, 0664);  //fd를 리턴
char *p_map = mmap((void *)0, 8192, PROT_READ|PORT_WRITE, MAP_SHARED, fd, 0);  //fd와 대응된 가상 메모리 주소를 리턴
close(fd);
```

p_map에 데이터를 쓰면 fd도 변경되고, fd의 내용을 수정하면 p_map의 내요도 변경된다.

복수의 프로세스가 같은 파일에 대해 mmap을 호출하면 가상 주소가 달라도 실제로 가리키는 물리적인 주소가 동일하게 되어 공유의 효과를 가진다.

mmap의 장점

- 블록 장치에 접근할 때 시스템 콜을 거치지 않기 때문에 좀 더 가볍다. 
- lseek 함수를 쓰지 않고도 메모리맵의 특정 주소 변지로 이동하여 원하는 오프셋에서 읽거나 쓸 수 있다.
- 메모리맵에 쓰기를 시도하는 경우 일반 파일보다 더 오랜 시간 동안 dirty page로 유지될 가능성이 커서, I/O처리가 빈번한 파일이라면 메모리맵을 사용하는 편이 성능 측면에서 유리해진다. 
- 읽기용으로만 사용하는 데이터일 경우에도 지역성의 원리에 의해 캐시 히트될 가능성이 커진다.
- posix_madvise(혹은 madvise) 기능을 사용하면 미리 읽기(prefetching) 같은 기능도 사용할 수 있다. 이는 TLB 최적화 등의 이점을 가진다.

## 속성

### 권한

mmap에는 rwx권한이 존재하는데, 원래 rwx는 파일에 사용되는 권한이다. mmap은 파일과 맵핑되는 사본의 개념이므로 같은 개념의 권한이 존재하지만, mmap에서는 메모리 영역(페이지)을 보호하기 위한 개념이 되어 용어가 달라진다. mmap에서는 대응하는 권한 부분을 프로텍션(protection)이라고 부른다.[^1]

만일 mmap에 쓰기 프로텍션을 허용하는 경우에는 공유 방식의 차이에 따라서 다르게 작동된다.

- shared mmap : 다수 프로세스가 공유한다.
- private map : 쓰기가 발생하기 전까지는 공유하고 쓰기가 발생하면 COW(copy-on-write)로 특정 프로세스에게 전용된다.[^2]

strace ls

### 가상 메모리

1. 스왑(swap) : 물리 메모리의 크기보다 더 큰 공간을 사용하기 위해, 블록 장치(주로 디스크)의 일부를 물리 메모리와 교환하는 과정.

|page out/swap out|페이지를 메모리→디스크 로 이동시킨다|
|page in/swap in|페이지를 디스크→메모리 로 이동시킨다|

스왑을 위해 OS는 블록 장치에 스왑을 위한 공간을 미리 확보해두는데, 리눅스에서는 주로 스왑 파티션을 사용하고, 윈도우 계열은 페이지 파일이라는 특수 파일을 사용한다.

2. file-backed 메모리 : 페이지 중에 특정 경로에 이미 원본이 존재하는 경우

file-backed 메모리의 대표적인 예로는 실행 파일이나 DLL의로딩이 해당된다. 혹은 몇몇 프로그램에서 공통으로 사용되는 데이터, 이미지 파일도 같은 방식으로 로딩되는 경우가 많다.

/proc/meminfo를 확인하면 Active(file), Inactive(file) 항목에서 file-backed 메모리의 양을 알아볼 수 있다.

### 주요 특징과 함수

mmap의 주요 특징

- 대응된 메모리 맵은 포인터로 접근하므로 사용이 쉽다.
- 시스템 호출을 통하지 않고도 파일의 내용에 접근할 수 있다.
- 메모리와 파일 사이의 동기화는 운영체제가 담당하므로 편리하다.
- 공유된 mmap을 사용할 때는 크리티컬 섹션 보호에 신경 써야 한다.
- 대응된 메모리 맵의 크기를 넘어서는 경우 파일에 영향을 주지 않는다.

mmap 관련 함수들

|mmap|메모리를 파일(혹은 장치)에 대응시킨다.|
|munmap|mmap을 해제한다.|
|msync|메모리와 파일을 동기화한다.|
|mprotect|mmap을 접근 권한을 변경한다.|
|mremap|mmap을 재조정한다.(리눅스 고유 함수이므로, _GUN_SOURCE 매크로 필요)|

기타 사항

- mmap을 사용할 때 대응시킬 대상 파일은 대응하고자 하는 메모리의 크기보다 커야만 한다. 만일 파일의 크기가 작다면 ftruncate를 이용해서 키우든지 해야 한다.
- 익명 mmap라는 램 디스크의 용도로 사용되는 경우에는 원본 파일이 필요 없다.

## 공유 방식 : 공유(shared), 사설(private) 방식

공유 방식<br>
여러 개의 프로세스가 하나의 메모리와 파일을 사용하는 것처럼 작동한다.<br>
어떤 한 프로세스가 mmap을 변경하면 동일한 mmap을 보는 다른 모든 프로세스도 변경된 내용을 보게 된다. 물론 파일도 같이 변경된다.<br>
다만 파일의 동기화에는 시간차가 있을 수 있기 때문에 mmap으로 대응된 원본 파일을 다른 프로세스에서 직접 읽을 때는 최신의 데이터가 아닐 수도 있다.<br>
항상 원본 파일이 블록 장치에 존재하기 때문에 스왑 아웃의 대상이 되지 않는 장점이 있다.<br>
직접 write 함수를 사용하는 것보다 성능도 좋다.

사설 방식<br>
처음 mmap이 생성된 뒤에 프로세스가 독자적으로 사용하는 메모리 공간으로 전용할 수 있다.<br>
내용이 변경된 사설 방식의 mmap 페이지는 해당 프로세스 고유의 메모리 공간으로 전환되므로 스왑 아웃이 가능한 페이지로 전용된다. 이에 따라 메모리가 낭비되거나 성능상의 이점이 사라질 수도 있다.<br>
성능을 위해 스왑 아웃을 금지하고자 한다면 mlock으로 페이징 금지를 걸어두어야만 한다.<br>
이외에 메모리 조언(posix_madvise)을 이용해서 좀 더 효율적으로 작동하도록 하는 방법이 있다.

기본적으로 mmap은 스레드 안전(thread-safety)을 만족하고 있다. map이 스레드 안전을 만족한다는 것은 멀티 프로세스나 스레드가 서로 공유된 mmap에 쓰기를 시도하더라도 안전하다는 것이다. 물론 크리티컬 섹션의 보호는 필요하다. 하지만, 공유된 mmap과 대응된 파일이 항상 같다고는 보장할 수 없어서 여러 프로세스가 mmap과 파일에 대해 읽기, 쓰기를 병행하는 경우에는 msync로 동기화를 마치고 읽어 들이는 것이 좋다.

mmap 사용이 끝낸 뒤에는 munmap으로 해제할 수 있다. 하지만, 다른 프로세스에서도 계속 사용하고 있다면 해제하지 않는다.<br>
또한, 공유 방식으로 생성된 mmap이라면 대응을 풀기 전에 msync로 동기화를 마치고 푸는 것이 좋다.

## 사용법

- mmap 함수

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

start 인수는 mmap으로 리턴받기 원하는 가상 주소 시작 번지이다. 보통 0을 설정하면 자동으로 알맞은 주소를 할당한다. 보통 0을 설정하면 자동으로 알맞은 주소를 할당한다. 만일 고정된 주소를 할당받고자 한다면 flags에 MAP_FIXED를 세팅하고 start에는 페이지 크기의 경계에 맞도록 입력한다. 시스템의 페이지 크기는 sysconf(_SC_PAGESIZE)로 확인할 수 있다.

length는 mmap을 생성할 메모리 크기로서 대응할 대상 파일이 mmap의 최소 length보다는 커야 한다. 만일 파일 크기가 더 작다면 에러가 발생한다. 

mmap의 proto 인수 플래그

|PROTO_READ|해당 데이터는 읽기 가능하다.|
|PROTO_WRITE|해당 데이터는 쓰기 가능하다.|
|PROTO_EXEC|해당 데이터는 실행 가능하다.|
|PROTO_NONE|해당 데이터는 접근이 불가능하다.|

mmap의 flags 인수 플래그

|MAP_SHARED|공유 가능한 메모리 맵으로 지정한다. 파일과 메모리는 동기화된다.|
|MAP_PRIVATE|사설 메모리 맵으로 지정한다. 생성할 때는 파일 내용과 동일한 메모리 맵이 생성되지만, 이후로는 동기화되지 않는다. 읽기 전용일 때 사용한다.|
|MAP_FIXED|원하는 메모리 시작 번지를 지정하고자 할 때 사용한다.|
|MAP_ANONYMOUS|장치와 연결되지 않은 익명 mmap을 생성한다. 임시 페이지에 쓰인다.|
|MAP_HUGETLB|HugeTLB를 사용하여 대용량 데이터 처리를 할 수 있도록 한다.|
|MAP_LOCKED|페이지 락을 이용한다. MLOCK에서 제공하는 기능과 같다.|
|MAP_UNINITIALIZED|익명 mmap으로 할당된 공간을 초기화하지 않는다.(성능을 중시하는 경우에 유용)|

MAP_ANONYMOUS는 특정 주소에 페이지를 끼워 넣을 필요가 있거나 순서대로 페이지를 배열할 필요가 있을 때 사용한다. 이 옵션을 사용하면 mmap 함수의 5,6번째 인수(fd, offset)는 무시되지만 fd는 과거 코드와의 호환성을 위해 보통 -1로 설정한다.

MAP_HUGETLB는 mmap으로 대용량 데이터를 취급할 때 TLB hit rate가 떨어져서 메모리 접근 성능이 떨어지는 것을 해결하기 위해 사용한다. 일반적인 시스템에서 메모리 접근 성능이 떨어지는 것을 해결하기 위해 사용한다. 일반적인 시스템은 4096바이트의 페이지 크기를 사용하는데 엄청 큰 파일을 mmap으로 사용한다면 TLB 히트될 가능성이 줄어들고 PTE도 커지기 때문에 시스템의 전반적인 성능 하락을 피할 수 없게 된다.<br>
이런 단점을 해결하기 위해 현대적인 아키텍처에는 대용량 데이터를 표현하기에 적합하도록 2, 4MiB 혹은 1GiB처럼 huge page를 사용하는 경우가 있다. 주로 대용량 데이터베이스 시스템이나 복수 개의 프로세스가 협업하는 시뮬레이션이나 네트워크 서버에서 이 기능을 사용하면 효과를 볼 수 있다. MAP_HUGETLB 기능은 커널 설정도 필요하다.

MAP_UNINITIALIZED는 MAP_ANONYMOUS와 같이 쓰이는 옵션이며 초기화가 필요없는 경우에 이 옵션을 이요하면 메모리 접근을 최소화하므로 성능을 좀 더 올릴 수 있다. 이 옵션이 없는 경우 기본적으로 익명 mmap은 0(zero)으로 초기화된 페이지를 반환한다.

- msync 함수

```c
int msync(void *start, size_t length, int flags);
```

msync의 flags 인수 플래그

|MS_ASYNC|msync 함수는 바로 리턴되며, 동기화는 비동기로 진행된다.<br>따라서 함수 리턴 뒤에도 동기화는 예약될 뿐 보장할 수는 없다.|
|MS_SYNC|msync 함수는 동기화를 마칠 때까지 리턴되지 않는다.<br>동기화는 바로 진행되며 리턴과 동시에 동기화의 완료가 보장된다.|
|MS_INVALIDATE|메모리에 쓰인 값을 무효화하고 파일에서 다시 데이터를 로딩하여 메모리에 덮어쓰게 된다.|

```c
int munmap(void *start, size_t length);
```

## 메모리 사용 패턴 조언(memory advice)

메모리 조언 기능 : mmap이나 공유 메모리에서 프로그래머의 의도에 따라 메모리를 어떻게 사용할 것인지 힌트를 줄 수 있는 기능

이런 힌트가 없으면 프로그래머가 원하는게 순차접근인지, 랜덤접근인지, 더 이상 사용하지 않는지 등을 OS는 미리 알 수가 없다.그러므로 OS는 함부로 프리패치(prefetch) 할 수 없기에 가장 기본적인 방식으로 I/O 처리를 하는데, 이런 방식은 대용량 입출력을 하는 고성능 시스템에서는 불합리한 것이 된다.

메모리 조언 함수는 posix_madvise와 madvise가 있다.[^3] 둘의 차이점은 표준의 차이 정도로 기능면에서는 거의 동일하다. 

```c
int posix_madvise(void *addr, size_t len, int advice);
```

posix_madvise의 advise 인수

|POSIX_MADV_NORMAL|해당 메모리에는 아무런 권고 사항이 없다.(기본값)|
|POSIX_MADV_SEQUENTIAL|해당 메모리를 순서대로 접근할 것이다.|
|POSIX_MADV_RANDOM|해당 메모리를 랜덤으로 접근할 것이다.|
|POSIX_MADV_WILLNEED|해당 메모리를 가까운 미래에 사용할 것이다.|
|POSIX_MADV_DONTNEED|해당 메모리를 앞으로 사용하지 않을 것이다.|

```C
int posix_fadvise(int fd, off_t offset, off_t len, int advice);
```

posix_fadvise의 advise 인수

|POSIX_FADV_NORMAL|해당 파일에는 아무런 권고 사항이 없다.(기본값)|
|POSIX_FADV_SEQUENTIAL|해당 파일을 순서대로 접근할 것이다.|
|POSIX_FADV_RANDOM|해당 파일을 랜덤으로 접근할 것이다.|
|POSIX_FADV_WILLNEED|해당 파일을 가까운 미래에 사용할 것이다.|
|POSIX_FADV_DONTNEED|해당 파일을 앞으로 사용하지 않을 것이다.|

## mmap의 대용량 페이지 기능: Huge Page

리눅스에서 Huge Page를 사용하는 방법은 2가지이다.

- 명시적으로 Huge Page를 사용하는 방법

커널 설정으로 Huge Page로 전용할 공간을 확보하고 프로그램 소스 코드에 명시적으로 Huge Page를 사용하겠다고 지정하는 방법. 이렇게 할당된 메모리는 일반 페이지로 사용할 수 없어 과다하게 Huge Page로 할당하면 메모리 부족을 겪을 수 있다.

- 묵시적으로 사용하는 THP(Transparent Huge Page)를 사용하는 방법.

THP 설정
|always|THP 사용 (기본값)|
|madvise|madvise 함수를 적용한 mmap에 대해서만 사용함|
|never|THP 사용 안함|

```c
hugeadm --thp-always
cat /sys/kernel/mm/transparent_hugepage/enabled
```

### Huge Page filesystem

```c
hugeadm --pool-pages-min 2M:1G
hugeadm --pool-pages-max 2M:10G
hugeadm --pool-list

hugeadm --create-mounts
mount | grep -i hugetlbfs
```



### hugeadm

레드햇 계열에서는 libhugetlbfs-utils 패키지에 있으며, 데비안 계열에서는 hugepages에 있다.

# SysV와 POSIX의 IPC

XSI IPC 유틸리티

|ipcs|IPC status, 시스템의 XSI IPC 자원 리스트를 출력한다.|
|ipcrm|IPC remove, 시스템의 XSI IPC 자원을 제거한다.|
|lsipc|list of IPC, XSI IPC 설정을 출력한다.(리눅스 전용)|

- XSI IPC key 관리

```c
key_shm = ftok("/usr/local/bin/ipc_daemon", 101);
```

```c
/* ftok의 키 사용 */
key_t key_shm = ftok("/usr/local/bin/ipc_daemon", 101);
int id_shm = shmget(key_shm, size_shm, flag_shm);

/* 사설 IPC키 사용 */
int id_shm = shmget(IPC_PRIVATE, size_shm, flag_shm);
```

- ipcs와 ipcrm

```c
ipcs -a
```

### librt

리눅스의 리얼타임 확장 라이브러리


# 공유 메모리(shared memory)



## XSI

XIS 공유 메모리 관련 함수

|shmget|공유 메모리의 IPC ID를 얻는다. (없는 경우에 생성하면서 ID가 반환된다.)|
|shmat|지정한 IPC ID에 해다오디는 공유 메모리와 연결한다.<br>성공시 공유 메모리와 연결된 주소 번지를 반환한다.(attach)|
|shmdt|공유 메모리와의 연결을 해제한다. (detach)|
|shmctl|공유 메모리를 조작한다.(제거, 메타 데이터 얻기)|

```c
int shmget(key_t key, int size, int shmflg);
void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
```

shmget의 플래그

|IPC_CREAT|해당 IPC 자원이 존재하지 않으면 생성한다.|
|IPC_EXCL|해당 IPC 자원이 이미 존재하면 에러(EEXIST)를 발생시킨다.|
|SHM_HUGETLB|SHM에 Huge page를 사용한다. 리눅스에서만 지원하는 기능이다.|

- XSI 공유 메모리의 시스템 설정

XSI 공유 메모리 관련 전역 설정

|kernel.shmmni|시스템에 생성 가능한 공유 메모리의 최대 개수(Max, number of identifier)|
|kernel.shmmax|공유 메모리 1개의 최대 크기(단위: 바이트)|
|kernel.shmall|시스템에서 할당 가능한 전체 공유 메모리 페이지 개수 설정(단위: 페이지)|

```c
sysctl -a | grep shm
```

- XSI 공유 메모리의 제거

```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
struct shmid_ds {
  struct ipc_perm shm_perm;  /* 패딩 필드는 생략했다 */
  size_t shm_segsz;  /* 퍼미션 */
  time_t shm_atime;  /* 세그먼트의 크기(bytes) */
  time_t shm_dtime;  /* 마지막으로 shmat()를 호출한 시간 */
  time_t shm_ctime;  /* 마지막으로 shmdt()를 호출한 시간 */
  pid_t shm_cpid;  /* 공유 메모리의 생성 시간 */
  pid_t shm_lpid;  /* 공유 메모리를 생성한 프로세스의 pid */
  shmatt_t shm_nattch;  /* 현재 접근한 프로세스의 수 (연결 개수) */
}
```

shmctl의 cmd 명령어

|IPC_STAT|IPC 자원의 정보(생성자, 생성 시작, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다. (리눅스 전용 가능)|
|IPC_RMID|IPC 자원을 제거한다.|

- XSI 공유 메모리 예제



## POSIX

- 생성

POSIX 공유 메모리에서 사용하는 함수들

|shm_open|POSIX 공유 메모리의 기술자를 얻음(생성 포함)|
|mmap|공유 메모리 기술자를 메모리 맵으로 맵핑|
|close|공유 메모리 기술자를 닫음|
|shm_unlink|POSIX 공유 메모리를 제거|

```c
int shm_open(const char *name, int oflag, mode_t mode);
```

- 삭제

```c
int shm_unlink(const char *name);
```



# 세마포어(semaphore)

리눅스에서 제공되는 일반적인 락 메커니즘의 종류

|카운팅 세마포어|복수 개의 자원 카운팅이 가능한 세마포어|
|이진 세마포어|1개의 자원 카운팅이 가능한 세마포어|
|뮤텍스(MUTEX)|독점적인 획득이 가능하게 하는 특수한 형태의 락|
|스핀락|문맥 교환을 막기 위해 사용되는 매우 빠른 특수한 형태의 락|
|Reader/Writer락(rwlock)|읽기, 쓰기가 서로 다르게 적용되는 특수한 형태의 락|

리눅스의 세마포어와 뮤텍스 특징 비교

||XSI 세마포어|POSIX 세마포어|POSIX 뮤텍스|
|---|---|---|---|
|최대 카운터|semvmx 시스템 설정<br>(SUS 표준에서는 32767)|SEM_VALUE_MAX|1|
|독점적 소유권|불가능|불가능|가능|
|동작 취소(undo)|가능|불가능|가능|
|타이머 설정|가능(비표준 함수)|가능|가능|

## XSI

XSI 세마포어의 중요 값들

|semval|현재 세마포어 값|
|sempid|마지막으로 세마포어에 접근했던 프로세스의 PID|
|semcnt|세마포어 카운트(semval)가 양수가 되기를 대기하는 프로세스의 개수|
|semnzcnt|세마포어 카운트(semval)가 0이 되기까지 대기하는 프로세스의 개수|

XSI 세마포어 함수들
 
|semget|세마포어 세트의 IPC ID를 얻는다.(없는 경우에 생성하면서 ID를 반환할 수 있다.)|
|semctl|세마포어를 조작한다.(제거, 메타 데이터 읽기, 초기화 등)|
|semop|세마포어 값을 증감시킨다.|
|semtimedop|semop에 타임아웃 기능이 추가된 함수이다.<br>(이 함수는 리눅스 전용이므로 2016년 기준으로는 비표준 함수이다.)|

- 생성/삭제

```c
int semget(key_t key, int nsems, int semflg);

int semctl(int semid, int semnum, int cmd, ...);
```

semctl에 쓰이는 cmd 인수값(특별히 리턴값을 표시하지 않는 명령은 성공시 0을 리턴)

|SETVAL|세마포어 세트 중에 semnum 위치의 세마포어의 값을 초기화한다.|
|SETALL|세마포어 세트의 모든 세마포어를 배열을 이용해서 한꺼번에 초기화한다.|
|GETVAL|세마포어 세트 중에 semnum 위치의 세마포어의 값을 리턴한다.|
|GETALL|세마포어 세트의 모든 세마포어를 배열을 이용해서 한꺼번에 읽어온다.|
|GETNCNT|세마포어 세트 중에 semnum 위치의 세마포어의 semncnt 정보를 리턴한다.|
|GETZCNT|세마포어 세트 중에 semnum 위치의 세마포어의 semzcnt 정보를 리턴한다.|
|GETPID|세마포어 세트 중에 semnum 위치의 세마포어의 sempid 값을 리턴한다.|
|IPC_STAT|IPC 자원의 정보(생성자, 생성시각, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다.(리눅스 전용 기능)|
|IPC_RMID|IPC 자원을 제거한다.|

세마포어 ID 데이터 구조체

```c
/* Data structure describing a set of semaphores. */
struct semid_ds {
  struct ipc_perm sem_perm;
  time_t sem_otime;
  time_t sem_ctime;
  unsigned long int sem_nsems;
}

struct ipc_perm {
  key_t __key;
  uid_t uid;
  gid_t gid;
  uid_t cuid;
  gid_t cgid;
  unsigned short int mode;
  unsigned short int __seq;
}
```

세마포어 리눅스 커널 파라미터 구조체

```c
struct seminfo {
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
}
```

리눅스의 XSI 세마포어 커널 파라미터

|semmap|세마포어 맵의 엔트리 제한. 즉 세마포어 정보를 저장하는 엔트리 맵 개수<br>(일반적으로 10~2147483647 (2Gi-1)개로 제한됨)|
|semmni|시스템 내에 최대로 만들 수 있는 세마포어 세트의 개수(IPC ID의 개수)<br>(max, number of identifier, 일반적으로 10~65,535개로 제한)|
|semmns|(max, number of semaphore, 일반적으로 60~2,147,483,647개로 제한됨)<br>시스템 내에 만들 수 있는 세마포어의 최대 개수|
|semmnu|(max, number of undo, 일반적으로 30~2,147,483,647개로 제한됨)<br>시스템 내에 만들 수 있는 undo 구조체의 최대 개수|
|semmsl|한개의 세마포어 세트 내에 만들 수 있는 세마포어의 개수(IPC ID당 세마포어 개수)<br>(일반적으로 25~2,147,483,647개로 제한됨, 단 smemns보다 클 수 없다.)|
|semopm|semop 콜의 최대값. 즉 semop 함수의 세 번째 인수의 최대값을 제한<br>
|semume|프로세스당 최대 undo 엔트리의 개수|
|semusz|undo 구조체가 사용하는 메모리 크기|
|semvmx|세마포어 값의 최대값.<br>세마포어는 최대값에 따라 동시 진입 개수를 한정할 수 있다.|
|semaem|프로세스의 종료시 복구 될 수 있는 undo의 최대값|

XSI 세마포어의 리눅스 시스템 설정

```c
sysctl -a | grep sem
```

```c
./sysv_sem_info
```

- 랩핑 함수의 제작

- XSI 세마포어의 사용 : P, V 동작

```c
int semop(int semid, struct sembuf *sops, unsigned nsops);
int semtimedop(int semid, struct sembuf *sops, unsigned nsops, struct timespec *timeout);
```

sem_flg에 가능한 옵션 플래그

|SEM_UNDO|세마포어를 조작한 프로세스가 종료되었을 때 조작된 작업은 취소되고 대기하던 다음 세마포어 오퍼레이션이 실행된다.|
|IPC_NOWAIT|사용 가능한 자원이 없는 경우(세마포어 값이 0인 경우)에 기다리지 않고 바로 에러 리턴한다. 그리고 errno는 EAGAIN으로 세팅된다.|

- XSI 세마포어의 사용 : wait-for-zero 동작



## POSIX

POSIX 세마포어 함수들

|sem_init|익명 세마포어를 생성 후 초기화된다.|
|sem_open|명명된 세마포어를 생성 후 초기화하거나 오픈한다.|
|sem_wait|세마포어 값을 1 감소시킨다.(P 오퍼레이션)|
|sem_trywait|sem_wait의 넌블럭킹 기능이 추가된 함수이다.(P 오퍼레이션)|
|sem_timedwait|sem_wait의 타임아웃 기능이 추가된 함수이다.(P 오퍼레이션)|
|sem_post|세마포어 값을 1 증가시킨다.(V 오퍼레이션)|
|sem_getvalue|세마포어 카운터 값을 읽어온다.|
|sem_destroy|익명 세마포어를 제거한다.|
|sem_close|명명된 세마포어와의 연결을 해제한다.(제거하지는 않는다.)|
|sem_unlink|명명된 세마포어를 시스템에서 제거한다.|

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
sem_t *sem_open(const char *name, int oflag, ...);
```

- POSIX 세마포어의 사용 : P, V 동작

```c
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
int sem_post(sem_t *sem);
struct timespec {
  time_t tv_sec;   /* Seconds */
  long tv_nsec;    /* Nanoseconds [0 .. 999999999] */
}
```

- 제거





# 메시지 큐



## XSI

XSI 메시지 큐 함수들

|msgget|메시지 큐에 IPC ID를 얻는다. (없는 경우에 생성하면서 ID를 반환할 수 있다.)|
|msgsnd|메시지 큐에 데이터를 송싱한다. (쓰기 작업)|
|msgrcv|메시지 큐로부터 데이터를 수신한다. (읽기 작업)|
|msgctl|메시지 큐를 조작한다. (제거 및 설정 읽어오기)|

- 생성/삭제

```c
int msgget(key_t key, int msgflg);
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

msgget의 플래그

|IPC_CREAT|해당 IPC 자원이 존재하지 않으면 생성한다.|
|IPC_EXCL|해당 IPC 자원이 이미 존재하면 에러(EEXIST)를 발생시킨다.|

- 송수신

```c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
struct msgbuf {
  long mtype;    /* message type, must be > 0 */
  char mtext[1];    /* message data array */
}
```

msgsnd와 msgrcv의 사용 가능한 msgflg

|msgsnd|IPC_NOWAIT|msgsnd를 넌블럭킹 모드로 작동하게 한다.|
|msgrcv|IPC_NOWAIT|msgrcv를 넌블럭킹 모드로 작동하게 한다.|
|msgrcv|MSG_NOERROR|수신받은 메시지가 지정한 msgsz 인수보다 클 때 에러를 내지 않고 초과된 부분을 잘라버린다.|
|msgrcv|MSG_EXCEPT|메시지 타입 인수(msgtyp)를 초과하는 메시지만 수신한다.(GNU 확장)|

msgrcv의 msgtyp 인수의 값

|양수|해당 양수와 일치하는 메시지 타입만 수신한다.|
|0|메시지 타입을 무시하고 큐에 있는 메시지를 입력된 순서대로 수신한다.|
|음수|해당 음수의 절대값과 같거나 작은 숫자의 메시지 타입을 순서대로 수신한다.|

- 시스템 설정

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

msgctl에 쓰이는 cmd 인수값

|IPC_STAT|IPC 자원의 정보(생성자, 생성시각, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다. (리눅스 전용 기능)|
|IPC_RMID|IPC 자원을 제거한다.|

```c
sysctl -a | grep kernel.msg
```



## POSIX

POSIX 메시지 큐 함수들

|mq_open|메시지 큐의 객체를 얻는다. (없는 경우에 생성하면서 반환 할 수 있다.)|
|mq_close|메시지 큐를 닫는다. (닫김난 할 뿐 시스템에는 남아 있다.)|
|mq_unlink|메시지 큐를 시스템에서 제거한다.|
|mq_send|메시지 큐에 데이터를 송신한다.(쓰기 작업)|
|mq_timedsend|mq_send에 타임아웃 기능이 추가된 함수이다.(쓰기 작업)|
|mq_receive|메시지 큐로부터 데이터를 수신한다.(읽기 작업)|
|mq_timedreceive|mq_receive에 타임아웃 기능이 추가된 함수이다.(읽기 작업)|
|mq_setattr|메시지 큐의 속성을 설정한다.|
|mq_getattr|메시지 큐의 속성을 읽어온다.|
|notify|메시지 큐에 데이터가 도착했을 때 통지 기능을 이용한다. (시그널, 스레드 작업)|

- 생성/삭제

```c
mqd_t mq_open(const char *name, int oflag, ...);
int mq_close(mqd_t mqdes);
int mq_unlink(const char *name);
```

- 송수신

```c
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio);
int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout);
struct timespec {
  time_t tv_sec;   /* Seconds */
  long tv_nsec;    /* Nanoseconds [0 .. 999999999] */
}
```

```c
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio);
ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr, size_t msg_len, unsigned *restrict msg_prio, const struct timespec *restrict abs_timeout);
```


- 이벤트 통지

```c
int mq_notify(mqd_t mqdes, const struct sigevent *notification);
```

- 속성

```c
int mq_setattr(mqd_t mqdes, const struct mq_attr *restrict mqstat, struct mq_attr*restrict omqstat);
int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat);
```



[^1]: 프로텍션에 대해서는 자세히 설명하지 않는다. 사실 잘 모른다.
[^2]: COW가 발생한 private mmap은 더는 공유 페이지가 아니므로 추가적인 메모리를 요구하게 된다.
[^3]: 파일용으로는 posix_fadvise가 있다.

