---
title: "시스템프로그래밍-IPC"
category:
  - system programming
tag:
  - system programming
  - linux
toc: true
toc_sticky: true
---

# IPC(Inter-Process Communication)

IPC : 프로세스 사이에서 통신을 가능케 하는 매커니즘의 통칭.

이론적으로 매우 폭넓은 기술을 아우르고 있다. 예로 일반 파일, mmap, 세마포어, 공유 메모리, 메시지 큐, 파이프, 소켓 등의 모든 통신 기법이 이에 해당한다.

SVIPC(SysV IPC) 혹은 XSI IPC 혹은 XSI(X System Interface) : 유닉스 계통에서 보통 IPC라고 하면 초기 SysV 유닉스 계열에서 IPC를 구현하면서 만들어진 3가지 기법을 말하는 경우가 맣다. 바로 공유 메모리, 세모파어, 메시지 큐로서 SysV 형식을 따르는 경우다.

그리고 POSIX 표준에서 새로이 제정된 IPC도 있는데 이를 POSIX IPC라고 부른다. 이렇듯 현대적인 유닉스, 리눅스에서는 XSI, POSIX 방식의 IPC 기법이 표준 내에서 공존하고 있다. XSI는 옛날부터 사용되어 왔고 아직 많은 DB 서버나 각종 서비스에서 사용되고 있으나 점점 POSIX 방식으로 대체되어 가고 있다.




# mmap(memory mapped I/O)

- mmap의 권한 : 읽기, 쓰기, 실행
- mmap의 공유 방식 : shared mmap, private mmap


## 속성

strace ls

mmap 관련 함수들

|mmap|메모리를 파일(혹은 장치)에 대응시킨다.|
|munmap|mmap을 해제한다.|
|msync|메모리와 파일을 동기화한다.|
|mprotect|mmap을 접근 권한을 변경한다.|
|mremap|mmap을 재조정한다.(리눅스 고유 함수이므로, _GUN_SOURCE 매크로 필요)|

- 공유 방식 : 공유(shared), 사설(private) 방식



## 사용법

- mmap 함수

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

mmap의 proto 인수 플래그

|PROTO_READ|해당 데이터는 읽기 가능하다.|
|PROTO_WRITE|해당 데이터는 쓰기 가능하다.|
|PROTO_EXEC|해당 데이터는 실행 가능하다.|
|PROTO_NONE|해당 데이터는 접근이 불가능하다.|

mmap의 flags 인수 플래그

|MAP_SHARED|공유 가능한 메모리 맵으로 지정한다. 파일과 메모리는 동기화된다.|
|MAP_PRIVATE|사설 메모리 맵으로 지정한다. 생성할 때는 파일 내용과 동일한 메모리 맵이 생성되지만, 이후로는 동기화되지 않는다. 일긱 전용일 때 사용한다.|
|MAP_FIXED|원하는 메모리 시작 번지를 지정하고자 할 때 사용한다.|
|MAP_ANONYMOUS|장치와 연결되지 않은 익명 mmap을 생성한다. 임시 페이지에 쓰인다.|
|MAP_HUGETLB|HugeTLB를 사용하여 대용량 데이터 처리를 할 수 있도록 한다.|
|MAP_LOCKED|페이지 락을 이용한다. MLOCK에서 제공하는 기능과 같다.|
|MAP_UNINITIALIZED|익명 mmap으로 할당된 공간을 초기화하지 않는다.(성능을 중시하는 경우에 유용)|

- msync 함수

```c
int msync(void *start, size_t length, int flags);
```

msync의 flags 인수 플래그

|MS_ASYNC|msync 함수는 바로 리턴되며, 동기화는 비동기로 진행된다. 따라서 함수 리턴 뒤에도 동기화는 예약될 뿐 보장할 수는 없다.|
|MS_SYNC|msync 함수는 동기화를 마칠 때까지 리턴되지 않는다.동기화는 바로 진행되며 리턴과 동시에 동기화의 완료가 보장된다.|
|MS_INVALIDATE|메모리에 쓰인 값을 무효화하고 파일에서 다시 데이터를 로딩하여 메모리에 덮어쓰게 된다.|

```c
int munmap(void *start, size_t length);
```

## 메모리 사용 패턴 조언(memory advice)

메모리 조언 기능의 목적을 알려면 지역성(Principle of locality)과 메모리 체계(memory hierarchy)의 기본 개념부터 알아야 한다.

```c
int posix_madvise(void *addr, size_t len, int advice);
```

posix_madvise의 advise 인수

|POSIX_MADV_NORMAL|해당 메모리에는 아무런 권고 사항이 없다.(기본값)|
|POSIX_MADV_SEQUENTIAL|해당 메모리를 순서대로 접근할 것이다.|
|POSIX_MADV_RANDOM|해당 메모리를 랜덤으로 접근할 것이다.|
|POSIX_MADV_WILLNEED|해당 메모리를 가까운 미래에 사용할 것이다.|
|POSIX_MADV_DONTNEED|해당 메모리를 앞으로 사용하지 않을 것이다.|

```C
int posix_fadvise(int fd, off_t offset, off_t len, int advice);
```

posix_fadvise의 advise 인수

|POSIX_FADV_NORMAL|해당 파일에는 아무런 권고 사항이 없다.(기본값)|
|POSIX_FADV_SEQUENTIAL|해당 파일을 순서대로 접근할 것이다.|
|POSIX_FADV_RANDOM|해당 파일을 랜덤으로 접근할 것이다.|
|POSIX_FADV_WILLNEED|해당 파일을 가까운 미래에 사용할 것이다.|
|POSIX_FADV_DONTNEED|해당 파일을 앞으로 사용하지 않을 것이다.|

## mmap의 대용량 페이지 기능: Huge Page

리눅스에서 Huge Page를 사용하는 방법은 2가지이다.

- 명시적으로 Huge Page를 사용하는 방법

커널 설정으로 Huge Page로 전용할 공간을 확보하고 프로그램 소스 코드에 명시적으로 Huge Page를 사용하겠다고 지정하는 방법. 이렇게 할당된 메모리는 일반 페이지로 사용할 수 없어 과다하게 Huge Page로 할당하면 메모리 부족을 겪을 수 있다.

- 묵시적으로 사용하는 THP(Transparent Huge Page)를 사용하는 방법.

THP 설정
|always|THP 사용 (기본값)|
|madvise|madvise 함수를 적용한 mmap에 대해서만 사용함|
|never|THP 사용 안함|

```c
hugeadm --thp-always
cat /sys/kernel/mm/transparent_hugepage/enabled
```

### Huge Page filesystem

```c
hugeadm --pool-pages-min 2M:1G
hugeadm --pool-pages-max 2M:10G
hugeadm --pool-list

hugeadm --create-mounts
mount | grep -i hugetlbfs
```



### hugeadm

레드햇 계열에서는 libhugetlbfs-utils 패키지에 있으며, 데비안 계열에서는 hugepages에 있다.

# SysV와 POSIX의 IPC

XSI IPC 유틸리티

|ipcs|IPC status, 시스템의 XSI IPC 자원 리스트를 출력한다.|
|ipcrm|IPC remove, 시스템의 XSI IPC 자원을 제거한다.|
|lsipc|list of IPC, XSI IPC 설정을 출력한다.(리눅스 전용)|

- XSI IPC key 관리

```c
key_shm = ftok("/usr/local/bin/ipc_daemon", 101);
```

```c
/* ftok의 키 사용 */
key_t key_shm = ftok("/usr/local/bin/ipc_daemon", 101);
int id_shm = shmget(key_shm, size_shm, flag_shm);

/* 사설 IPC키 사용 */
int id_shm = shmget(IPC_PRIVATE, size_shm, flag_shm);
```

- ipcs와 ipcrm

```c
ipcs -a
```

### librt

리눅스의 리얼타임 확장 라이브러리


# 공유 메모리(shared memory)



## XSI

XIS 공유 메모리 관련 함수

|shmget|공유 메모리의 IPC ID를 얻는다. (없는 경우에 생성하면서 ID가 반환된다.)|
|shmat|지정한 IPC ID에 해다오디는 공유 메모리와 연결한다.<br>성공시 공유 메모리와 연결된 주소 번지를 반환한다.(attach)|
|shmdt|공유 메모리와의 연결을 해제한다. (detach)|
|shmctl|공유 메모리를 조작한다.(제거, 메타 데이터 얻기)|

```c
int shmget(key_t key, int size, int shmflg);
void *shmat(int shmid, const void *shmaddr, int shmflg);
int shmdt(const void *shmaddr);
```

shmget의 플래그

|IPC_CREAT|해당 IPC 자원이 존재하지 않으면 생성한다.|
|IPC_EXCL|해당 IPC 자원이 이미 존재하면 에러(EEXIST)를 발생시킨다.|
|SHM_HUGETLB|SHM에 Huge page를 사용한다. 리눅스에서만 지원하는 기능이다.|

- XSI 공유 메모리의 시스템 설정

XSI 공유 메모리 관련 전역 설정

|kernel.shmmni|시스템에 생성 가능한 공유 메모리의 최대 개수(Max, number of identifier)|
|kernel.shmmax|공유 메모리 1개의 최대 크기(단위: 바이트)|
|kernel.shmall|시스템에서 할당 가능한 전체 공유 메모리 페이지 개수 설정(단위: 페이지)|

```c
sysctl -a | grep shm
```

- XSI 공유 메모리의 제거

```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
struct shmid_ds {
  struct ipc_perm shm_perm;  /* 패딩 필드는 생략했다 */
  size_t shm_segsz;  /* 퍼미션 */
  time_t shm_atime;  /* 세그먼트의 크기(bytes) */
  time_t shm_dtime;  /* 마지막으로 shmat()를 호출한 시간 */
  time_t shm_ctime;  /* 마지막으로 shmdt()를 호출한 시간 */
  pid_t shm_cpid;  /* 공유 메모리의 생성 시간 */
  pid_t shm_lpid;  /* 공유 메모리를 생성한 프로세스의 pid */
  shmatt_t shm_nattch;  /* 현재 접근한 프로세스의 수 (연결 개수) */
}
```

shmctl의 cmd 명령어

|IPC_STAT|IPC 자원의 정보(생성자, 생성 시작, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다. (리눅스 전용 가능)|
|IPC_RMID|IPC 자원을 제거한다.|

- XSI 공유 메모리 예제



## POSIX

- 생성

POSIX 공유 메모리에서 사용하는 함수들

|shm_open|POSIX 공유 메모리의 기술자를 얻음(생성 포함)|
|mmap|공유 메모리 기술자를 메모리 맵으로 맵핑|
|close|공유 메모리 기술자를 닫음|
|shm_unlink|POSIX 공유 메모리를 제거|

```c
int shm_open(const char *name, int oflag, mode_t mode);
```

- 삭제

```c
int shm_unlink(const char *name);
```



# 세마포어(semaphore)

리눅스에서 제공되는 일반적인 락 메커니즘의 종류

|카운팅 세마포어|복수 개의 자원 카운팅이 가능한 세마포어|
|이진 세마포어|1개의 자원 카운팅이 가능한 세마포어|
|뮤텍스(MUTEX)|독점적인 획득이 가능하게 하는 특수한 형태의 락|
|스핀락|문맥 교환을 막기 위해 사용되는 매우 빠른 특수한 형태의 락|
|Reader/Writer락(rwlock)|읽기, 쓰기가 서로 다르게 적용되는 특수한 형태의 락|

리눅스의 세마포어와 뮤텍스 특징 비교

||XSI 세마포어|POSIX 세마포어|POSIX 뮤텍스|
|---|---|---|---|
|최대 카운터|semvmx 시스템 설정<br>(SUS 표준에서는 32767)|SEM_VALUE_MAX|1|
|독점적 소유권|불가능|불가능|가능|
|동작 취소(undo)|가능|불가능|가능|
|타이머 설정|가능(비표준 함수)|가능|가능|

## XSI

XSI 세마포어의 중요 값들

|semval|현재 세마포어 값|
|sempid|마지막으로 세마포어에 접근했던 프로세스의 PID|
|semcnt|세마포어 카운트(semval)가 양수가 되기를 대기하는 프로세스의 개수|
|semnzcnt|세마포어 카운트(semval)가 0이 되기까지 대기하는 프로세스의 개수|

XSI 세마포어 함수들
 
|semget|세마포어 세트의 IPC ID를 얻는다.(없는 경우에 생성하면서 ID를 반환할 수 있다.)|
|semctl|세마포어를 조작한다.(제거, 메타 데이터 읽기, 초기화 등)|
|semop|세마포어 값을 증감시킨다.|
|semtimedop|semop에 타임아웃 기능이 추가된 함수이다.<br>(이 함수는 리눅스 전용이므로 2016년 기준으로는 비표준 함수이다.)|

- 생성/삭제

```c
int semget(key_t key, int nsems, int semflg);

int semctl(int semid, int semnum, int cmd, ...);
```

semctl에 쓰이는 cmd 인수값(특별히 리턴값을 표시하지 않는 명령은 성공시 0을 리턴)

|SETVAL|세마포어 세트 중에 semnum 위치의 세마포어의 값을 초기화한다.|
|SETALL|세마포어 세트의 모든 세마포어를 배열을 이용해서 한꺼번에 초기화한다.|
|GETVAL|세마포어 세트 중에 semnum 위치의 세마포어의 값을 리턴한다.|
|GETALL|세마포어 세트의 모든 세마포어를 배열을 이용해서 한꺼번에 읽어온다.|
|GETNCNT|세마포어 세트 중에 semnum 위치의 세마포어의 semncnt 정보를 리턴한다.|
|GETZCNT|세마포어 세트 중에 semnum 위치의 세마포어의 semzcnt 정보를 리턴한다.|
|GETPID|세마포어 세트 중에 semnum 위치의 세마포어의 sempid 값을 리턴한다.|
|IPC_STAT|IPC 자원의 정보(생성자, 생성시각, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다.(리눅스 전용 기능)|
|IPC_RMID|IPC 자원을 제거한다.|

세마포어 ID 데이터 구조체

```c
/* Data structure describing a set of semaphores. */
struct semid_ds {
  struct ipc_perm sem_perm;
  time_t sem_otime;
  time_t sem_ctime;
  unsigned long int sem_nsems;
}

struct ipc_perm {
  key_t __key;
  uid_t uid;
  gid_t gid;
  uid_t cuid;
  gid_t cgid;
  unsigned short int mode;
  unsigned short int __seq;
}
```

세마포어 리눅스 커널 파라미터 구조체

```c
struct seminfo {
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
}
```

리눅스의 XSI 세마포어 커널 파라미터

|semmap|세마포어 맵의 엔트리 제한. 즉 세마포어 정보를 저장하는 엔트리 맵 개수<br>(일반적으로 10~2147483647 (2Gi-1)개로 제한됨)|
|semmni|시스템 내에 최대로 만들 수 있는 세마포어 세트의 개수(IPC ID의 개수)<br>(max, number of identifier, 일반적으로 10~65,535개로 제한)|
|semmns|(max, number of semaphore, 일반적으로 60~2,147,483,647개로 제한됨)<br>시스템 내에 만들 수 있는 세마포어의 최대 개수|
|semmnu|(max, number of undo, 일반적으로 30~2,147,483,647개로 제한됨)<br>시스템 내에 만들 수 있는 undo 구조체의 최대 개수|
|semmsl|한개의 세마포어 세트 내에 만들 수 있는 세마포어의 개수(IPC ID당 세마포어 개수)<br>(일반적으로 25~2,147,483,647개로 제한됨, 단 smemns보다 클 수 없다.)|
|semopm|semop 콜의 최대값. 즉 semop 함수의 세 번째 인수의 최대값을 제한<br>
|semume|프로세스당 최대 undo 엔트리의 개수|
|semusz|undo 구조체가 사용하는 메모리 크기|
|semvmx|세마포어 값의 최대값.<br>세마포어는 최대값에 따라 동시 진입 개수를 한정할 수 있다.|
|semaem|프로세스의 종료시 복구 될 수 있는 undo의 최대값|

XSI 세마포어의 리눅스 시스템 설정

```c
sysctl -a | grep sem
```

```c
./sysv_sem_info
```

- 랩핑 함수의 제작

- XSI 세마포어의 사용 : P, V 동작

```c
int semop(int semid, struct sembuf *sops, unsigned nsops);
int semtimedop(int semid, struct sembuf *sops, unsigned nsops, struct timespec *timeout);
```

sem_flg에 가능한 옵션 플래그

|SEM_UNDO|세마포어를 조작한 프로세스가 종료되었을 때 조작된 작업은 취소되고 대기하던 다음 세마포어 오퍼레이션이 실행된다.|
|IPC_NOWAIT|사용 가능한 자원이 없는 경우(세마포어 값이 0인 경우)에 기다리지 않고 바로 에러 리턴한다. 그리고 errno는 EAGAIN으로 세팅된다.|

- XSI 세마포어의 사용 : wait-for-zero 동작



## POSIX

POSIX 세마포어 함수들

|sem_init|익명 세마포어를 생성 후 초기화된다.|
|sem_open|명명된 세마포어를 생성 후 초기화하거나 오픈한다.|
|sem_wait|세마포어 값을 1 감소시킨다.(P 오퍼레이션)|
|sem_trywait|sem_wait의 넌블럭킹 기능이 추가된 함수이다.(P 오퍼레이션)|
|sem_timedwait|sem_wait의 타임아웃 기능이 추가된 함수이다.(P 오퍼레이션)|
|sem_post|세마포어 값을 1 증가시킨다.(V 오퍼레이션)|
|sem_getvalue|세마포어 카운터 값을 읽어온다.|
|sem_destroy|익명 세마포어를 제거한다.|
|sem_close|명명된 세마포어와의 연결을 해제한다.(제거하지는 않는다.)|
|sem_unlink|명명된 세마포어를 시스템에서 제거한다.|

```c
int sem_init(sem_t *sem, int pshared, unsigned int value);
sem_t *sem_open(const char *name, int oflag, ...);
```

- POSIX 세마포어의 사용 : P, V 동작

```c
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
int sem_post(sem_t *sem);
struct timespec {
  time_t tv_sec;   /* Seconds */
  long tv_nsec;    /* Nanoseconds [0 .. 999999999] */
}
```

- 제거





# 메시지 큐



## XSI

XSI 메시지 큐 함수들

|msgget|메시지 큐에 IPC ID를 얻는다. (없는 경우에 생성하면서 ID를 반환할 수 있다.)|
|msgsnd|메시지 큐에 데이터를 송싱한다. (쓰기 작업)|
|msgrcv|메시지 큐로부터 데이터를 수신한다. (읽기 작업)|
|msgctl|메시지 큐를 조작한다. (제거 및 설정 읽어오기)|

- 생성/삭제

```c
int msgget(key_t key, int msgflg);
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

msgget의 플래그

|IPC_CREAT|해당 IPC 자원이 존재하지 않으면 생성한다.|
|IPC_EXCL|해당 IPC 자원이 이미 존재하면 에러(EEXIST)를 발생시킨다.|

- 송수신

```c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
int msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
struct msgbuf {
  long mtype;    /* message type, must be > 0 */
  char mtext[1];    /* message data array */
}
```

msgsnd와 msgrcv의 사용 가능한 msgflg

|msgsnd|IPC_NOWAIT|msgsnd를 넌블럭킹 모드로 작동하게 한다.|
|msgrcv|IPC_NOWAIT|msgrcv를 넌블럭킹 모드로 작동하게 한다.|
|msgrcv|MSG_NOERROR|수신받은 메시지가 지정한 msgsz 인수보다 클 때 에러를 내지 않고 초과된 부분을 잘라버린다.|
|msgrcv|MSG_EXCEPT|메시지 타입 인수(msgtyp)를 초과하는 메시지만 수신한다.(GNU 확장)|

msgrcv의 msgtyp 인수의 값

|양수|해당 양수와 일치하는 메시지 타입만 수신한다.|
|0|메시지 타입을 무시하고 큐에 있는 메시지를 입력된 순서대로 수신한다.|
|음수|해당 음수의 절대값과 같거나 작은 숫자의 메시지 타입을 순서대로 수신한다.|

- 시스템 설정

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

msgctl에 쓰이는 cmd 인수값

|IPC_STAT|IPC 자원의 정보(생성자, 생성시각, 접근 권한 등등)을 읽어온다.|
|IPC_SET|IPC 자원의 정보(권한)를 변경한다.|
|IPC_INFO|IPC 자원의 시스템 설정 값을 읽어온다. (리눅스 전용 기능)|
|IPC_RMID|IPC 자원을 제거한다.|

```c
sysctl -a | grep kernel.msg
```



## POSIX

POSIX 메시지 큐 함수들

|mq_open|메시지 큐의 객체를 얻는다. (없는 경우에 생성하면서 반환 할 수 있다.)|
|mq_close|메시지 큐를 닫는다. (닫김난 할 뿐 시스템에는 남아 있다.)|
|mq_unlink|메시지 큐를 시스템에서 제거한다.|
|mq_send|메시지 큐에 데이터를 송신한다.(쓰기 작업)|
|mq_timedsend|mq_send에 타임아웃 기능이 추가된 함수이다.(쓰기 작업)|
|mq_receive|메시지 큐로부터 데이터를 수신한다.(읽기 작업)|
|mq_timedreceive|mq_receive에 타임아웃 기능이 추가된 함수이다.(읽기 작업)|
|mq_setattr|메시지 큐의 속성을 설정한다.|
|mq_getattr|메시지 큐의 속성을 읽어온다.|
|notify|메시지 큐에 데이터가 도착했을 때 통지 기능을 이용한다. (시그널, 스레드 작업)|

- 생성/삭제

```c
mqd_t mq_open(const char *name, int oflag, ...);
int mq_close(mqd_t mqdes);
int mq_unlink(const char *name);
```

- 송수신

```c
int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio);
int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abs_timeout);
struct timespec {
  time_t tv_sec;   /* Seconds */
  long tv_nsec;    /* Nanoseconds [0 .. 999999999] */
}
```

```c
ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio);
ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr, size_t msg_len, unsigned *restrict msg_prio, const struct timespec *restrict abs_timeout);
```


- 이벤트 통지

```c
int mq_notify(mqd_t mqdes, const struct sigevent *notification);
```

- 속성

```c
int mq_setattr(mqd_t mqdes, const struct mq_attr *restrict mqstat, struct mq_attr*restrict omqstat);
int mq_getattr(mqd_t mqdes, struct mq_attr *mqstat);
```




