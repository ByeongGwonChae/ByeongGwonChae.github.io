---
title: "시스템프로그래밍-텍스트 처리"
category:
  - system programming
tag:
  - system programming
  - linux
toc: true
toc_sticky: true
---

텍스트 처리에 관한 함수는 크게 텍스트를 읽어내는 입력 함수와 복사 및 출력 형태를 결정하는 함수들로 이루어져 있다.

보통 텍스트를 처리할 때 일일이 한 바이트씩 읽어서 비교하거나 memchr, strchr 게열의 함수를 이용해 찾는 방법은 제대로 작성되었을 때 매우 빠를 수 있다. 하지만, 이런 하드 코딩 방법은 입력 텍스트의 규격이나 형태가 약간만 변해도 재작성해야 하는 부분이 상당히 많아진다. 심지어 완벽히 새로 작성해야 하는 문제가 발생할 수도 있다. 이런 제약은 입력뿐 아니라 출력 부분도 마찬가지다. 예를 들어 어떤 프로그램이 다른 스크립트 언어와 호환하는 구조로 만들어져야 한다든지 혹은 실시간으로 재컴파일 없이 어떤 입출력을 수정할 필요가 있다면 하드 코딩은 선택하기 꺼려질 것이ㅏㄷ.

이때 사용 가능한 기법이 바로 정규 표현식이다. 정규 표현식을 사용하면 다음과 같은 작업을 쉽게 할 수 잇다.

ex1) 전역 환경(global Configuration)으로 사용되는 파일이 있는데 이 파일의 규격은 셸(shell) 형식이며, 다른 스크립트 언어에서도 사용하는 구조로서 각 언어에 맞게 쉽게 추출, 변환될 수 있어야만 한다.

ex2) 데이터베이스에서 넘겨받은 데이터에 특정 문자열이나 데이터가 있는지 검색해야 하는 경우가 생겼다. 그런데 검색어가 지정된 문자열이 아니라 메일 주소, URL, 욕설 패턴 같은 동적으로 바뀔 수 있는 형태이다.

# 정규표현식(REGEX)의 이용

처리해야하는 텍스트가 아주 단순하고 정형화된 규격이라면 memchr, strchr, strtok 같은 함수를 이용하거나 직접 버퍼에 접근해서 바이트 단위로 처리하는 것은 괜찮은 방법이다. 하지만, 입력 데이터가 종종 변하거나 규격이 추가된다든지 하는 경우라면 매번 코딩을 바꿔야 하기 때문에 비효율적일 수 있다.

정규표현식은 직접 비교하는 방식보다 속도가 느릴 가능성도 있지만, 원체 빠른 C언어이므로 이 정도의 속도 저하로는 큰 문제가 발생하는 경우는 없을 것이다. 그래서 약간의 성능을 희생하더라도 좀 더 편리하고 강한 정규 표현식이 훨씬 유용할 것이다.

C언어에서 정규표현식의 구현은 BSD 방식과 POSIX 방식이 존재한다. 보통은 호환성 문제 때문에 역시 POSIX 정규 표현식을 사용하는 함수가 더 나은 경우가 많다. 따라서 이책에서도 POSIX 기준의 함수를 설명하도록 할 것이다.

참고로 이외에 PCRE(Perl Compatible Regular Expression)라는 매우 강력한 확ㅈ장 정규 표현식 기능이 있으므로 POSIX 스타일로 해결되지 않는다면 PCRE를 고려해보는 것도 좋은 방법이다.

PCRE의 새로운 버전에서는 POSIX 스타일의 랩핑 함수도 제공되니 pcre2 관련 패키지 설치 후 pcre2posix 매뉴얼 페이지를 읽어보기를 권장한다.

POSIX 정규표현식 관련 함수

|regcomp|정규표현식 패턴 문자열을 패턴 버퍼로 컴파일|
|regexec|컴파일된 패턴 버퍼를 검색할 문자열에 적용|
|regfree|패턴 버퍼에 할당된 메모리를 해제|
|regerror|에러 보고|

정상적인 경우라면 순서대로 regcomp, regexec, regfree 순으로 사용된다. regerror는 regcomp가 에러를 발생시켰을 때 에러의 원인을 찾기 위해서만 사용된다.

posix_regex.c

원래 컴파일이란 데이터를 수집, 처리하여 다른 형태로 만들어내는 과정이다. 즉 여기의 패턴 컴파일이란 정규 표현식을 사용하기 위해서 기계가 일긱 위한 형태로 데이터를 수집하고 공간을 확보하는 것이다.

## 패턴 버퍼의 컴파일과 실행

int regcomp(reget_t *restrict preg, const char *restrict pattern, int cflags);

두 번재 인수인 pattern은 정규 표현식 문자열로서 이를 해석해서 regex_t 타입의 패턴 버퍼인 preg로 컴파일하는 구조로 되어 있다.

그리고 플래그인 int cflags는 어떤 방식의 정규 표현식 패턴으로 인식할 것인지를 지정한다. cflags에 지정할 수 있는 플래그를 밑에 정리해두었는데 각 플래그는 bitwise-inclusive OR로 결합할 수 있다.

regcomp의 옵션 플래그

|REG_EXTENDED|POSIX 확장 정규 표현식 문법을 적용|
|REG_ICASE|대소문자 구분을 무시|
|REG_NOSUB|서브 스트링 기능을 무시. 즉 ()괄호 부분만을 데어 보고하는 작업을 하지 않는다.|
|REG_NEWLINE|.나[...],[^...] 등의 요소들이 NEW LINE과는 매칭하지 않는다.|

행 단위로 문자열 매칭 작업을 할 때는 REG_NEWLINE 플래그가 꼭 필요하다. 만일 이를 지정하지 않으면 문서 전체에 대해서 매칭 작업을 하게 된다. 그러므로 보통은 REG_EXTENDED와 REG_NEWLINE을 많이 사용한다.

regcomp는 실패했을 때 regerror로 에러의 원인을 찾을 수 있게 도와준다. 만일 성공하면 regcomp의 첫 번째 인수에는 메모리가 할당된 패턴 버퍼가 리턴되고 이를 다시 regexec에 너허서 문자열을 검사하면 된다.

int regexec(const regex_t *restrict preg, const char *restrict string, size_t nmatch, regmatch_t pmatch[restrict], int eflags)

첫 번재 인수는 regcomp에서 컴파일했던 패턴 버퍼를 넣고, 두 번째는 검사할 문자열을 넣는다. 그리고 3~5번째 인수는 매칭 결과를 보고할 매칭 테이블의 개수와 매칭 테이블 변수의 배열, 옵션 플래그 순으로 넣어준다. 여기서 옵션 플래그인 eflag에는 다음과 같은 것들이 있다. 만일 특별한 옵션이 필요 없다면 0을 넣고 매칭을 시작한다.

regexec의 옵션 플래그

|REG_NOTBOL|(not beginning-of-line) 라인의 시작 패턴인 ^를 사용하지 못한다.|
|REG_NOTEOL|(not end-of-line) 라인의 마지막 패턴인 $를 사용하지 못한다.|

regexec는 성공하면 0을 리턴하고 실패하면 REG_NOMATCH를 리턴한다. 만일 성공하였다면 4번째 인수인 매치 테이블 pmatch 배열 인수에 매칭에 성공한 문자열의 오프셋 위치를 저장하여 리턴한다. 그래서 매칭 테이블 구조체인 regmatch_t에는 단 두개의 정수형을 가지고 있고 시작 오프셋, 끝 오프셋을 가리킨다.

typedef struct {
    regoff_t rm_so; /* 매칭에 성공한 시작 오프셋 */
    regoff_t rm_eo; /* 매칭에 성공한 끝 오프셋 */
} regmatch_t;

매칭 테이블이 배열로 지정되는 이유는 0번째 배열에는 전체 매칭된 오프셋을 저장하고 1번째부터는 소괄호인 ()로 지정한 오프셋 주소를 저장하기 때문이다.



원래 정규표현식은 greedy 매칭으로 작동하여 최대한 많은 수와 매칭하려 한다.

regexec의 매칭을 위해서 사용되었던 패턴 버터(regex_t 타입)는 계속 재사용할 수 있지만, 더 사용되지 않는다면 regfree로 메모리 해제를 해야만 메모리 누수를 막을 수 있다.

## 패턴 버퍼 컴파일 에러 처리

regcomp에서 에러가 발생하면 REG_BADRPT, REG_BADBR ...등의 에러 코드를 리턴하게 된다. 이 값들이 의미하는 바는 man 페이지에 나와 있으니 참고하고 에러 발생 후 regerror로 자세한 메시지를 얻어낼 수 있다.

~~~ c
size_t regerror(int errcode, const regex_t *restrict preg, char *restrict errbuf, size_t errbuf_size);
~~~

첫 번재 인수는 앞서 regcomp가 실패했을 때 리턴한 값이다. 에러 메시지에는 정규 표현식이 잘못된 경우라면 구체적으로 어느 부분에서 문제가 생겼는지 밑줄로 표시해주므로 쉽게 교정할 수 있다.

# 새롭게 추가된 문자열 관련 함수

2008년도 개정된 SUSv4 표준에는 문자열이나 바이너리 데이터를 다루는 몇 가지 함수가 추가되었다. 전혀 새로운 것이라고는 할 수 없지만, 기존 함수들보다 편리한 몇 가지가 추가되었다.

문자열 관련 새로운ㅇ 함수(SUSv4 기준)

|stpcpy|문자열 복사 후 마지막 위치의 주소값을 넘겨준다.|
|stpncpy|최대값을 지정할 수 있는 stpcpy의 대체 함수|
|strnlen|최대값을 지정할 수 있는 strlen 대체 함수|
|strndup|최대값을 지정할 수 있는 strdup 대체 함수|
|strerror_r|strerror의 재진입 가능한 쓰레드 안전(thread-safe) 버전|
|getline|행 단위로 파일 읽기( 고수준 파일 처리 기능)|
|getdelim|구분자 단위로 파일 읽기 (고수준 파일 처리 기능)|

strcpy는 복수 개의 문자열을 붙일 때 꽤 유용한 함수로서 문자열을 복사한 뒤에 마지막 위치, 즉 널 종료 부분의 주소값을 넘겨준다.

얼핏 보면 기능이 strncat과 비슷하지만, 매번 문자열의 끝을 계산하기 위해 메모리를 탐색해야 하는 strncat보다 더 좋은 성능을 가진다. 더군다나 문자열의 끝이 넘어오기 때문에 코드를 중복해서 호출하여 쉽게 더할 수 있는 단점이 있다.

예를 들어 아래처럼 ice-cream을 붙일 때 연속으로 호출하여 쉽게 코딩할 수 있다.(아래 코드는 SUSv4에 포함된 예제이다.) 참고로 stpcpy와 ㅇ비슷하게 바이너리 데이터를 복사하고 마지막 위치의 주소값을 넘겨주는 memccpy도 있다.

~~~ c
char buffer[10];
char *name = buffer;
name = stpcpy (stpcpy (stpcpy (name, "ice"),"-"), "cream");
~~~

그리고 주목할 함수로 strnlen도 있다. 과거에 사용되던 strlen은 널 종료를 발견하지 못하면 메모리 한계를 넘어 탐색하여 성능면에서의 불이익이나 오류를 발생시킬 가능성이 있었다. 그래서 종종 GNU 확장으로 제공되던 strnlen을 사용했으나 이젠 표준 함수로 확정되었다.

