---
title: "인공지능-01. 소개"
category:
  - AI
tag:
  - AI
toc: true
toc_sticky: true
---

<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

이 시리즈는 '인공지능의 현대적 접근 방식' 이라는 책을 보고 거의 배끼듯 하고 있는데, 얼추 훑어봤다 싶으면 글을 지울 겁니다.

미래의 저는 이 글을 보고 반드시 지우시길...


# 역사

```python
def breadth_first_tree_search(problem):
    """
    [Figure 3.7]
    Search the shallowest nodes in the search tree first.
    Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    Repeats infinitely in case of loops.
    """

    frontier = deque([Node(problem.initial)])  # FIFO queue

    while frontier:
        node = frontier.popleft()
        if problem.goal_test(node.state):
            return node
        frontier.extend(node.expand(problem))
    return None
```



# 테스트

<div id="allalgorithm">
	<!-- Nav tabs -->
	<ul class="nav nav-tabs">
		<li class="nav-item">
			<a class="nav-link active" data-toggle="tab" href="#breadth_first_tree_search">Breadth First Tree Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#depth_first_tree_search">Depth First Tree Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm3">Breadth First Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm4">Depth First Graph Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm5">Best First Graph Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm6">Uniform Cost Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm7">Depth Limited Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm8">Iterative Deepening Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm9">Greedy Best First Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm10">A*-Search</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#algorithm11">Recursive Best First Search</a>
		</li>
	</ul>
	<!-- Tab panes -->
	<div class="tab-content">
		<div class="tab-pane container active" id="breadth_first_tree_search">
		```javascript
			def breadth_first_tree_search(problem):
"""
[Figure 3.7]
Search the shallowest nodes in the search tree first.
Search through the successors of a problem to find a goal.
The argument frontier should be an empty queue.
Repeats infinitely in case of loops.
"""
frontier = deque([Node(problem.initial)])  # FIFO queue
while frontier:
    node = frontier.popleft()
    if problem.goal_test(node.state):
        return node
    frontier.extend(node.expand(problem))
return None
```
		</div>
		<div class="tab-pane container fade" id="depth_first_tree_search">
			def depth_first_tree_search(problem):
"""
[Figure 3.7]
Search the deepest nodes in the search tree first.
Search through the successors of a problem to find a goal.
The argument frontier should be an empty queue.
Repeats infinitely in case of loops.
"""
frontier = [Node(problem.initial)]  # Stack
while frontier:
    node = frontier.pop()
    if problem.goal_test(node.state):
        return node
    frontier.extend(node.expand(problem))
return None
		</div>
		<div class="tab-pane container fade" id="algorithm3">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm4">
			<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 
def depth_first_graph_search(problem):
    """
    [Figure 3.7]
    Search the deepest nodes in the search tree first.
    Search through the successors of a problem to find a goal.
    The argument frontier should be an empty queue.
    Does not get trapped by loops.
    If two paths reach a state, only use the first one.
    """
    frontier = [(Node(problem.initial))]  # Stack

    explored = set()
    while frontier:
        node = frontier.pop()
        if problem.goal_test(node.state):
            return node
        explored.add(node.state)
        frontier.extend(child for child in node.expand(problem)
                        if child.state not in explored and child not in frontier)
    return None
			</code></pre></div></div>
		</div>
		<div class="tab-pane container fade" id="algorithm5">
			<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 
def breadth_first_graph_search(problem):
    """[Figure 3.11]
    Note that this function can be implemented in a
    single line as below:
    return graph_search(problem, FIFOQueue())
    """
    node = Node(problem.initial)
    if problem.goal_test(node.state):
        return node
    frontier = deque([node])
    explored = set()
    while frontier:
        node = frontier.popleft()
        explored.add(node.state)
        for child in node.expand(problem):
            if child.state not in explored and child not in frontier:
                if problem.goal_test(child.state):
                    return child
                frontier.append(child)
    return None
			</code></pre></div></div>
		</div>
		<div class="tab-pane container fade" id="algorithm6">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm7">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm8">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm9">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm10">
			a
		</div>
		<div class="tab-pane container fade" id="algorithm11">
			a
		</div>
	</div>
</div>





