---
title: "리눅스 - 프로세스"
category:
  - linux
tag:
  - linux
toc: true
toc_sticky: true
---

# 프로세스 종류

- 부모 프로세스
- 자식 프로세스
- 데몬 프로세스
- 고아 프로세스
- 좀비 프로세스

# 프로세스 목록 확인

```
ps           : 현재 실행 중인 프로세스 정보 출력
ps -ef       : 자세한 정보 출력 (유닉스 옵션)
ps aux       : 자세한 정보 출력 (유닉스 옵션)
ps -u <uid>  : 특정 사용자에 대한 프로세스 정보 출력
ps -p <pid>  : 지정한 pid의 프로세스 정보 출력
ps -t <term> : 특정 터미널에 대한 프로세스 정보 출력
ps --sort=<+pid> : 
```

## ps -ef 와 ps aux 비교

- 그냥 ps

![1](/assets/images/2020-02-26-리눅스-프로세스/1.png)

- ps -ef

![2](/assets/images/2020-02-26-리눅스-프로세스/2.png)

- ps aux

![3](/assets/images/2020-02-26-리눅스-프로세스/3.png)

## 특정 정보로 프로세스 찾기

1. uid로 검색

ps -u 옵션을 사용한다.

![4](/assets/images/2020-02-26-리눅스-프로세스/4.png)

2. pid로 검색

ps -p 옵션을 사용한다.

![5](/assets/images/2020-02-26-리눅스-프로세스/5.png)

3. 프로그램 이름(command)로 검색

ps -ef | grep <프로그램 이름>  을 사용한다.

![6](/assets/images/2020-02-26-리눅스-프로세스/6.png)

## pgrep

ps와 grep을 합쳐놓은 듯한 명령어.
<br>
uid, command 등으로 다양하게 검색 가능하며, 간단하게 pid만 출력하기에 다음과 같이 사용하기도 한다.

![9](/assets/images/2020-02-26-리눅스-프로세스/9.png)

단점으로는 `ps -e` 또는 `ps x` 처럼 시스템의 모든 프로세스를 검색하진 않기에, 검색 범위가 좁다.

```
pgrep [옵션] [패턴]
지정한 패턴과 일치하는 프로세스의 정보를 출력한다.

-x <pattern>  : 패턴과 정확히 일치하는 프로세스의 PID를 출력한다.
-n <pattern>  : 패턴을 포함하고 있는 가장 최근 프로세스의 PID를 출력한다.
-l            : PID와 함께 프로세스 이름도 출력한다.
-u <uid>      : 특정 사용자에 대한 모든 프로세스의 PID를 출력한다.
-t <term>     : 특정 터미널에 대한 모든 프로세스의 PID를 출력한다.
```

## 정렬해서 훑어보기

검색할 만한 정보가 없거나, 전체 목록을 훑어볼 때는 다음과 방법들을 쓸 수 있다.

1. `ps --sort` 옵션을 사용해서 정렬한다.

+는 오름차순이고, -는 내림차순이다. 한 번에 여러 항목을 정렬할 수 있다.

![10](/assets/images/2020-02-26-리눅스-프로세스/10.png)

2. `ps -ef | more`

![7](/assets/images/2020-02-26-리눅스-프로세스/7.png)

3. `pstree`

![8](/assets/images/2020-02-26-리눅스-프로세스/8.png)

# 실시간 프로세스 정보 확인 (top)

`ps --sort | mort` 등의 ps 명령은 현재 정보를 한 번 출력하고 끝나서, 주기적인 확인이 필요할 때는 ps를 수십 번 사용해야 하는 경우가 있다.

top 명령은 주기적으로 정보를 출력하기에, 실시간 정보 확인이 필요할 때 유용하다.

![11](/assets/images/2020-02-26-리눅스-프로세스/11.png)

터미널을 2개 열어서, 1번 터미널이 프로세스 관련 작업을 하는 동안, 그 작업을 2번 터미널에서 top명령으로 관제하는 식으로도 사용할 수 있다.

# 프로세스 종료하기

- kill : 프로세스를 pid로 검색
- pkill : 프로세스를 프로그램 이름(command)로 검색

```
kill [signal] PID
지정한 signal을 프로세스에 보낸다.

-l : 시스템에 정의된 signal 목록을 확인한다.
-2 : 인터럽트 signal을 보낸다. (Ctrl+c)
-9 : 프로세스를 강제로 종료한다.
     좀비 프로세스의 경우 9번 signal을 받아도 종료되지 않을 수 있다.
-15 : 프로세스가 관련된 파일을 정리하고 프로세스를 종료한다.
      종료되지 않는 프로세스가 있을 수 있다.
      기본적으로 kill에 옵션을 입력하지 않으면 15번 signal이 발생한다. (default)
```

```
pkill [signal] pattern
프로그램 이름(command)로 검색한 프로세스에 signal을 보낸다.
```

# 작업 제어

```
명령&            : 해당 명령을 백그라운드 작업으로 실행한다.
nohup 명령&      : 로그아웃한 뒤에도 백그라운드 작업을 계속 실행한다.

jobs             : 백그라운드 작업 목록을 출력한다.

fg [%작업 번호]   : 해당 작업을 포그라운드 작업으로 전환한다.
bg [%작업 번호]   : 해당 작업을 백그라운드 작업으로 전환한다.
stop [%작업 번호] : 포그라운드 작업을 잠시 중단한다.(Ctrl+z)
kill [%작업 번호] : 해당 작업을 종료한다.
```

# 작업 예약

- at : 정해진 시간에 한 번 명령을 실행
- crontab : 정해진 시간마다 반복하여 명령을 실행

## at

```
at [옵션] 시간
예약한 명령을 정해진 시간에 실행한다.

-l : 현재 실행 대기 중인 명령의 전체 목록을 출력한다.(atq과 동일)
-r 작업 번호 : 목록에서 해당 작업 번호를 삭제한다.(atrm과 동일)
-m : 출력 결과가 없더라도 작업이 완료되면 사용자에게 메일로 알려준다.
-f 파일 : 표준 입력 대신 실행할 명령을 파일로 지정한다.
```

### at 설치

- at 패키지 : at명령을 사용하는데 필요하다.
- mailutils 패키지 : 메일 관련 패키지. at명령의 결과를 받기 위해서 필요하다.
```
sudo apt-get install at
sudo apt-get intsall mailutils
```

### at 실행

먼저 `at 시간` 명령으로 보낼 시간을 설정해준다.
시간 설정은 여러가지로 할 수 있는데 `YYYY:MM:DD`나 `HH:MM`, `now`, `today`, `tomorrow`, `hours`, `days` 등으로 여러가지가 있다.

시간을 설정한 다음 실행할 명령을 입력하고 `Ctrl+d`로 빠져나온다.

![12](/assets/images/2020-02-26-리눅스-프로세스/12.png)

위의 이미지에서는 아직 메일이 도착을 안했으며, 1분 뒤 다시 `mail`명령을 실행하면 메일이 도착한 것을 확인할 수 있다.

![13](/assets/images/2020-02-26-리눅스-프로세스/13.png)

여기서 실행할 메일 번호를 입력하고 `Enter`를 누르면 설정했던 메일이 실행된다.

![14](/assets/images/2020-02-26-리눅스-프로세스/14.png)

## crontab

```
crontab [-u 사용자ID] [옵션] [파일명]
사용자의 crontab 파일을 관리한다. 명령을 주기적을 반복해서 실행.
-e          : 사용자의 crontab파일 생성 및 편집
-l          : crontab파일 내용 출력.
-l -u <uid> : 특정 사용자의 crontab파일 목록 출력
-r          : crontab파일 삭제.
```

## crontab 실행

crontab는 VISUAL 또는 EDITOR 환경변수로 편집기를 명시적으로 지정할 수 있다. (변수 설정을 안해도 편집기 선택은 가능하다.)

![15](/assets/images/2020-02-26-리눅스-프로세스/15.png)

vim편집기 내부로 들어가면 주석들이 있는데, 맨 마지막 줄을 보면 어떤식으로 사용해야하는지 나온다.

![16](/assets/images/2020-02-26-리눅스-프로세스/16.png)

순서대로 <br>① `분`<br>② `시`<br>③ `일`<br>④ `월`<br>⑤ `요일`<br>⑥ `command`<br> 을 의미한다.

①~⑤까지는 시간을 나타내며 `*`는 각 항목의 모든 값을 의미한다.
<br>
⑤ `요일`은 0~6까지의 값을 가지고 있고, 0이 일요일이며 1이 월요일, 6이 토요일이 된다.

![17](/assets/images/2020-02-26-리눅스-프로세스/17.png)

## at과 crontab 관련 파일들

해당 파일들은 보통 일반사용자들은 접근할 수 없으며, root나 시스템관리자만이 접근할 수 있다.

- /var/spool/cron/atjobs/ : at -l의 실행 대기 중인 목록이 각각 파일 형태로 저장된다.
- /etc/at.allow
- /etc/at.deny

- /etc/spool/cron/crontabs/사용자명 : crontab -e로 편집한 내용이 저장된다.
- /etc/cron.allow
- /etc/cron.deny
- /etc/cron.hourly, daily, weekly, nomthly : 기본적인 crontab명령은 개인별로 crontab을 작성하는 것에 반면, 해당 디렉터리에 셸스크립트 파일을 작성하면 모든 사용자들이 같은 명령을 실행할 수 있게 된다.

![18](/assets/images/2020-02-26-리눅스-프로세스/18.png)
