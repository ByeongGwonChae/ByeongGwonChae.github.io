---
title: "R 기초정리"
category:
  - R
tag:
  - note
toc: true
---

# 변수
온갖 데이터 타입들을 할당 받는다.\\
첫글자는 문자 또는 ‘.’ 으로 시작해야한다.\\
변수에 값을 할당할때는 <- 또는 <<- 또는 =[^1]를 사용한다.
# 1. 스칼라
R의 기본형은 벡터이므로 스칼라는 길이 1의 벡터로 볼 수 있다.\\
그러나 실제로는 편하게 스칼라 자료라고 생각해도 큰 문제는 없다.
## 1.1. 숫자
정수, 부동 소수 등이 자연스럽게 지원된다
## 1.2. NA (결측치)
만약 데이터에 __값이 존재하지 않는다__ 면 NA로 표시할 수 있다.\\
예를들어 4명의 시험점수가 있을 때 그 점수가 각각 80, 90, 75 이지만 4번째 사람의 점수를 모른다면 NA로 표현한다.
## 1.3 NULL
NULL은 NULL객체를 뜻하는데, __변수가 초기화 되지 않은 경우__ 등에 사용할 수 있다.\\
이는 NA와 구분하여 생각해야한다.
## 1.4 문자열
R은 C 등의 언어에서 볼 수 있는 한개 문자에 대한 데이터 타입은 없다. 대신 문자열로 모든 것을 처리한다.\\
문자열은 ‘this is string’ 또는 “this is string” 과 같이 어느 따옴표로 묶어도 된다.
## 1.5 Boolean
__1) TRUE, T는 참값을 말한다. FALSE, F는 거짓을 말한다.__\\
TRUE, FALSE는 예약어(reserved words)이며 T, F는 각각 TRUE와 FALSE로 초기화된 전역 변수이다.\\
따라서 다음과 같이 T에 FALSE를 할당하는 것이 가능한 반면 TRUE에는 FALSE를 할당할 수 없다.
~~~ R
> (T <- FALSE)
[1] FALSE
> (TRUE <- FALSE)
Error in TRUE <- FALSE : 대입에 유효하지 않은 (do_set) 좌변입니다
~~~
__2) 논리연산자에는 AND, OR, NOT 3가지가 있다.__\\
┌ AND연산자 : && , &\\
├ OR연산자 : || , |\\
└ NOT연산자 : !\\
&&와 &는 같은 AND연산자지만 벡터끼리의 연산에서는 차이점이 있다.[^2]\\
┌ &는 벡터의 각 셀들 전부 AND연산을 한다.\\
└ &&은 벡터의 맨 앞의 셀만 AND연산을 한다.
~~~ R
> c(TRUE, FALSE, TRUE) & c(TRUE, FALSE, FALSE)
[1] TRUE FALSE FALSE
> c(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE)
[1] TRUE
~~~
또한 &&, || 는 short-circuit을 지원한다.[^3]
# 2. 요인(Factor)
__범주형(Categorical) 변수__ 를 위한 데이터 타입.
~~~ R
> (sex <- factor("m", c("m", "f"))) #factor 선언
[1] m
Levels: m f
> nlevels(sex)  #범주의 수 확인하는 법
[1] 2
> levels(sex)  #범주 목록 확인하는 법
[1] "m" "f"
> levels(sex)[1]
[1] "m"
> levels(sex)[2]
[1] "f"
> (levels(sex) <- c('male', 'female'))  #level의 값을 수정하는 법
[1] "male"   "female"
~~~
factor는 기본적으로 데이터에 순서가 없으나(Nominal), 순서를 넣어줄 수도 있다.
~~~ R
> factor(c('a','b','c'))  #factor()는 기본적으로 명목형(Nominal) Factor를 만든다.
[1] a b c
Levels: a b c
> factor(c('a','b','c'), ordered=TRUE)  #순서형(Ordinal) Factor 만드는 법
[1] a b c
Levels: a < b < c
> ordered(c('a','b','c'))  #순서형(Ordinal) Factor 만드는 법
[1] a b c
Levels: a < b < c
~~~
# 3. 벡터(Vector)
## 3.1. 벡터의 정의
1) 벡터는 다른 프로그래밍 언어에서 흔히 보는 배열의 개념으로, c()안에 원하는 인자들을 나열하여 정의한다.\\
2) 나열하는 인자들은 __한가지 유형__ 의 스칼라 타입이어야한다.[^4]\\
3) 벡터는 중첩될 수 없다. 따라서 벡터 안에 벡터를 정의하면 이는 단일 차원의 벡터로 변경된다.[^5]\\
4) 숫자형 데이터의 경우 __start:end__ 또는 __seq(from, to, by)__ 등으로 벡터를 만들 수 있다.\\
5) __seq_along()__ , __seq_len()__ 등의 함수로도 벡터를 만들 수 있다.\\
6) __rep()__ 를 사용해 특정 값들이 반복된 벡터를 손쉽게 만들 수 있다.\\
7) __names()__ 함수를 통해 각 셀에 이름을 부여할 수 있다.
~~~ R
> (x <- c(1,2,3,4,5))  #벡터 선언
[1] 1 2 3 4 5
> (x <- c(1,2,c(3,4,5),6))  #벡터 안에 벡터 선언
[1] 1 2 3 4 5 6
> (x <- 1:10)  
[1]  1  2  3  4  5  6  7  8  9 10
> (x <- c(seq(1, 10, 2)))
[1] 1 3 5 7 9
> seq_along(c('a','b','c'))  #seq_along()은 인자로 주어진 데이터의 길이만큼 1:N 으로 구성된 벡터를 반환한다.
[1] 1 2 3
> seq_len(3)  #5) seq len()은 N값이 인자로 주어지면 1:N으로 구성된 벡터를 반환한다.
[1] 1 2 3
> rep(1:2, 5) #6) rep()을 사용해 특정 숫자들을 반복
[1] 1 2 1 2 1 2 1 2 1 2
> rep(1:2, each=5)  #6) rep()에 each를 붙일 경우
[1] 1 1 1 1 1 2 2 2 2 2
> x <- c(1, 3, 4)  #7) names() 벡터의 각 셀에 원하는 이름을 부여할 수 있다.
> (names(x) <- c("kim","seo","park"))
[1] "kim"  "seo"  "park"
> x
kim  seo park
  1    3    4
~~~
## 3.2. 벡터내 데이터 접근
1) 벡터는 [ ] 안에 인덱스를 적어서 각 요소를 가져올 수 있다.[^6]\\
2) '[-인덱스]' 를 사용해 특정 요소만 제외할 수도 있다.\\
3) ‘벡터명[색인 벡터]’ 을 사용해 벡터의 위치가 떨어져있는 값들을 가져올 수도 있다.\\
4) ‘x[start:end]’ 를 사용해 start부터 end까지의 데이터를 볼 수도 있다.[^7]\\
5) names()를 사용해 벡터의 각 셀에 이름을 부여하여 데이터에 접근할 수도 있다.
~~~ R
> x <- c("a","b","c")
> x[1]  #1) [ ]
[1] "a"
> x[-2]  #2) [-인덱스]
[1] "a" "c"
> x[c(1,3)]  #3) 벡터명[색인 벡터]
[1] "a" "c"
> x[1:2]  #4) x[start:end]
[1] "a" "b"
> (names(x) <- c("kim", "seo", "park"))  #5) names()
[1] "kim"  "seo"  "park"
> x[c("kim","park")]  #5) 이름으로 셀 검색
kim park
  1    3
> names(x)[2]  #5) 셀에 부여된 이름만 확인하기
[1] "seo"
~~~
__벡터의 길이 확인__ 하는 법 : length() 또는 NROW()[^8]\\
NROW()는 인자가 벡터인경우 벡터를 n행 1열의 행렬로 취급해 길이를 반환한다.
~~~ R
> x <- c("a","b","c")
> length(x)
[1] 3
> nrow(x)  #nrow()는 행렬만 사용 가능 (x는 벡터라서 사용 불가)
NULL
> NROW(x)  #NROW()는 벡터와 행렬 모두 사용 가능
[1] 3
~~~
## 3.3. 벡터 연산
1) __%in% 연산자__ 는 특정한 값이 벡터에 포함되어있는지를 알려준다\\
2) 벡터를 __집합(set)으로 취급__ 해 합집합(union), 교집합(setdiff), 차집합(intersect)을 계산할 수 있다.\\
3) 집합간 비교는 setequal()을 사용한다.
~~~ R
> 'a' %in% c('a','b','c')
[1] TRUE
> 'd' %in% c('a','b','c')
[1] FALSE
> union(c('a','b','c'), c('a','d'))  #2) 합집합
[1] "a" "b" "c" "d"
> setdiff(c('a','b','c'), c('a','d'))  #2) 교집합
[1] "b" "c"
> intersect(c('a','b','c'), c('a','d'))  #2) 차집합
[1] "a"
> setequal(c('a','b','c'), c('a','d'))  #3) 집합간 비교
[1] FALSE
> setequal(c('a','b','c'), c('a','b','c','c'))
[1] TRUE
~~~
# 4. 리스트(List)
리스트는 다른 언어에서 흔히 보는 해싱 또는 딕셔너리에 해당하며, (키,값) 형태의 데이터를 담는 연관 배열(associative array)이다
## 4.1 리스트의 정의
1) 리스트는 list(키=값, 키=값, ...) 형태로 데이터를 나열해 정의한다.\\
2) 각 값이 반드시 스칼라일 필요는 없으며 벡터를 저장해도 된다.\\
3) 다양한 값들을 혼합해서 저장할 수도 있다.\\
4) 리스트 안에 리스트를 중첩하는 것도 가능하다.
~~~ R
> (x <- list(name="foo", height=70))  #1) 리스트 선언
$name
[1] "foo"
$height
[1] 70
> (x <- list(name="foo", height=c(1,3,5))) #2)3) 다양한 값 혼합해서 저장 가능
$name
[1] "foo"
$height
[1] 1 3 5
> list(a=list(val=c(1,2,3)), b=list(val=c(1,2,3,4))) #4) 리스트 안에 리스트 중첩 가능
$a
$a$val
[1] 1 2 3
$b
$b$val
[1] 1 2 3 4
~~~
## 4.2. 리스트내 데이터 접근
1) 앞에서 본바와 같이 리스트를 출력해보면 ‘$키’ 형태로 각 키들이 나열된다.\\
2) ‘리스트 변수명$키’와 같이 데이터에 접근할 수 있다. \\
3) ‘리스트변수[[인덱스]]’와 같이 데이터의 각 요소를 순서대로 접근할 수도 있다.[^9]
~~~ R
> (x <- list(name="foo", height=c(1,3,5)))
$name
[1] "foo"
$height
[1] 1 3 5
> x$name
[1] "foo"
> x$height
[1] 1 3 5
> x[1]  #3) '(키,값)' 형태의 서브 리스트를 반환
$name
[1] "foo"
> x[[1]]  #3) 각 값을 반환
[1] "foo"
~~~
# 5. 행렬(Matrix)
벡터와 마찬가지로 행렬에는 한가지 유형의 스칼라만 저장할 수 있다.
## 5.1. 행렬의 정의
1) 행렬은 matrix( )를 사용해 표현한다. 다음은 1:9로 구성된 3행 3열의 행렬을 만드는 방법이다.\\
2) 행렬값을 나열한뒤 ncol(열의 수) 또는 nrow(행의 수)를 사용하 다.\\
3) default로 행렬값이 좌측 열부터 채워져오는데, 행렬값을 위쪽 행부터 채우고 싶다면 byrow를 사용한다.\\
4) dimnames()를 사용해서 행과 열에 명칭을 부여할 수 있다.
~~~ R
> matrix(c(1:9), nrow=3)
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> matrix(c(1:9),ncol=3)
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> matrix(c(1:9),nrow=3, byrow=T)  #3) 행렬값을 채우는 방향 바꾸기
     [,1] [,2] [,3]
[1,]147
[2,]258
[3,]369
> matrix(c(1:9), nrow=3, dimnames=list(c('item1','item2','item3'), c('feature1','feature2','feature3')))  #4) 명칭 부여
      feature1 feature2 feature3
item1        1        4        7
item2        2        5        8
item3        3        6        9
~~~
## 5.2. 행렬내 데이터 접근
1) 행렬의 각 요소는 ‘행렬이름[행인덱스, 열인덱스]’로 접근할 수 있다.[^10]\\
벡터와 마찬가지로\\
2) ‘-인덱스’와 같이 표현해 특정 행/열을 제외하거나,\\
3) ‘시작인덱스:끝인덱스’로 특정 범위의 데이터만 가져올 수도 있다.
4) 만약 특정 행이나 열의 전부를 가져오고 싶다면 행이나 열쪽에는 아무런 인덱스도 기재하지 않으면 된다.\\
5) 인덱스를 벡터에 넣어 나열할 수도 있다.
6) dimnames를 통해 행과 열에 이름을 부여했다면 그 이름을 직접 사용할 수도 있다
~~~ R
> (x <- matrix(c(1:9),ncol=3))
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> x[1,1]
[1] 1
> x[1:2,]
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
> x[-3,]    #위의 명령어와 결과가 같다.
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
> x[c(1,3), c(1,3)]
     [,1] [,2]
[1,]    1    7
[2,]    3    9
> (x <- matrix(c(1:9), nrow=3, dimnames=list(c('item1','item2','item3'), c('feature1','feature2','feature3'))))
      feature1 feature2 feature3
item1        1        4        7
item2        2        5        8
item3        3        6        9
> x['item1',]
feature1 feature2 feature3
       1        4        7
~~~
## 5.3. 행렬의 연산
~~~ R
> (x <- matrix(c(1:9), nrow=3))
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9
> x*2
   [,1] [,2] [,3]
[1,]28   14
[2,]4   10   16
[3,]6   12   18
> x/2
   [,1] [,2] [,3]
[1,]  0.5  2.0  3.5
[2,]  1.0  2.5  4.0
[3,]  1.5  3.0  4.5
#행렬끼리의 덧셈이나 뺄셈은 + 나 - 를 사용한다.
> x+x
   [,1] [,2] [,3]
[1,]28   14
[2,]4   10   16
[3,]6   12   18
> x-x
   [,1] [,2] [,3]
[1,]000
[2,]000
[3,]000
#행렬 곱은 %*% 를 사용한다.
#행렬 곱은 %*% 를 사용한다.
#  > x % * % x
#역행렬은 solve(행렬)로 계산한다.
#  > solve ( x )
#  > x % * % solve ( x )
#전치행렬은 t()로 구한다.
#  > t ( x )
#행렬의 차원은 ncol() 또는 nrow()로 알 수 있다
  > ncol ( x )
  > nrow ( x )
#역행렬은 solve(행렬)로 계산한다.
> (x<-matrix(c(1:4), ncol=2))
 [,1] [,2]
[1,]13
[2,]24
> solve(x)
 [,1] [,2]
[1,]   -2  1.5
[2,]1 -0.5
> x%*%solve(x)
 [,1] [,2]
[1,]10
[2,]01
#전치행렬은 t()로 구한다.
> t(x)
 [,1] [,2]
[1,]12
[2,]34
#행렬의 차원은 ncol() 또는 nrow()로 알 수 있다
> ncol(x)
[1] 2
> nrow(x)
[1] 2
~~~
# 6. 배열
## 6.1. 배열 정의
matrix가 2차원 행렬이라면 배열(array)은 n차원 행렬이다. 예를들어 3x4 matrix는 다음과 같이 array를 사용해 표현할 수 있다.
  ~~~ R
> matrix(1:12, ncol=4)
 [,1] [,2] [,3] [,4]
[1,]147   10
[2,]258   11
[3,]369   12
> array(1:12, dim=c(3,4))
 [,1] [,2] [,3] [,4]
[1,]147   10
[2,]258   11
[3,]369   12
#이번에는 이 데이터로 2x2x3 차원의 배열을 만들어보자.
> array(1:12, dim=c(2,2,3))
, , 1
 [,1] [,2]
[1,]13
[2,]24
, , 2
 [,1] [,2]
[1,]57
[2,]68
, , 3
 [,1] [,2]
[1,]9   11
[2,]   10   12
~~~
## 6.2. 배열 데이터 접근
행렬의 경우와 유사한 방식으로 각 요소에 접근할 수 있다. 또, 배열의 차원은 dim() 함수를 통해 알 수 있다
  ~~~ R
> (x<-array(1:12,dim=c(2,2,3)))
, , 1
 [,1] [,2]
[1,]13
[2,]24
, , 2
 [,1] [,2]
[1,]57
[2,]68
, , 3
 [,1] [,2]
[1,]9   11
[2,]   10   12
> x[1,2,3]
[1] 11
> x[,,3]
 [,1] [,2]
[1,]9   11
[2,]   10   12
> dim(x)
[1] 2 2 3
~~~
# 7. 데이터 프레임(Data Frame)
데이터 프레임은 R에서 가장 중요한 자료형이다. 데이터 프레임은 행렬과 마찬가지의 모습을 하고 있지만 행렬과 달리 다양한 변수, 관측치(observations), 범주 등을 표현하기 위해 특화되어있다.
data.frame() 을 사용해 정의한다
  ~~~ R
> (d <- data.frame(x=c(1:5), y=c(seq(1,10,2)+1)))
  x  y
1 1  2
2 2  4
3 3  6
4 4  8
5 5 10
> (d <- data.frame(x=c(1:5), y=c(seq(1,10,2)+1), z=c('M','F','M','F','M')))
  x  y z
1 1  2 M
2 2  4 F
3 3  6 M
4 4  8 F
5 5 10 M
#만약 이미 정의된 데이터 프레임에 새 열을 추가하고자한다면 ‘$열이름 <- ...’ 과 같은 형식으로 새로운 데이터를 추가할 수 있다.
> (d$v <- c(seq(1,15,3)+2))
[1]  3  6  9 12 15
> d
  x  y z  v
1 1  2 M  3
2 2  4 F  6
3 3  6 M  9
4 4  8 F 12
5 5 10 M 15
~~~
## 7.1. 데이터 프레임 접근
  ~~~ R
> d$x
[1] 1 2 3 4 5
> d[c(1,3),2]
[1] 2 6
> d[-1,-c(2,3)]
  x  v
2 2  6
3 3  9
4 4 12
5 5 15
> d[,c('x','y')]
  x  y
1 1  2
2 2  4
3 3  6
4 4  8
5 5 10
#컬럼을 1개만 선택했을때는 data.frame의 일반적인 모양인 표 형태가 아닌 벡터처럼 결과가 나온 것을 볼 수 있다. 이는 컬럼의 차원이 1이되면 자동으로 데이터 프레임이 아닌 벡터로 값을 반환하기 때문이다. 이를 피하려면 다음과 같이 drop=FALSE 옵션을 지정한다.
> d[,c('x'),drop=FALSE]
  x
1 1
2 2
3 3
4 4
5 5
#str()함수는 R 객체의 내부 구조를 보는데 사용되는 함수로 데이터 프레임을 인자로 받으면 데이터 타입등을 잘 정리해서 한눈에 보기쉽게 나타낸다.
#통상 R에서의 처리는 데이터 프레임을 기본 타입으로 하여 진행되므로 데이터 프레임에 많은 양의 데이터를 저장하게 된다. 이때 만약 단순히 데이터를 저장한 변수명을 입력하면 전체 데이터가 모두 출력되므로 데이터의 일부를 읽어보기가 어렵다. 이 경우 쉽게 데이터의 제일 앞부분만 살펴보는데 head()를 사용할 수 있다.
#데이터 프레임의 행 이름, 열 이름은 각각 rownames(), colnames() 함수로 지정할 수 있다.
> (x <- data.frame(1:3))
  X1.3
11
22
33
> (colnames(x) <- c('val'))
[1] "val"
> (rownames(x) <- c('a','b','c'))
[1] "a" "b" "c"
#또는 names()를 사용해도 colnames()와 같은 결과를 얻는다.
#주어진 값이 벡터에 존재하는지를 판별하는 %in% 연산자를 이용하면 특정 열만 선택하는 작업을 보다 손쉽게 할 수 있다.
> (d <- data.frame(a=1:3, b=4:6, c=7:9))
  a b c
1 1 4 7
2 2 5 8
3 3 6 9
> d[,names(d)%in%c('b','c')]
  b c
1 4 7
2 5 8
3 6 9
#위 코드에서 첫 줄의 (d <- data.frame...) 에는 명령의 처음과 끝에 괄호가 사용되었다. 이와 같은 방식으로 명령을 기술하면 해당 명령을 수행함과 동시에 결과값(여기서는 d)를 출력하는 작업까지 동시에 하게 된다.
#반대로 ! 연산자를 사용해 특정 값들만 제외해서 열을 선택할 수도 있다.
  > d[,!names(d)%in%c('a')]
  b c
1 4 7
2 5 8
3 6 9
~~~
# 8. 타입 판별
데이터를 처리하기 위해 여러 함수를 호출하다보면 반환된 결과의 타입이 무엇인지 분명하지 않을때가 있다. 이때는 다음과 같이 class()를 사용할 수 있다.
또는 str()문으로도 확인해 볼수 있다.
벡터와 행렬의 결과가 유사해보이지만 벡터의 경우 차원이 [1:2](1차원에 값이 2개)라고 표시되어있는 반면, 행렬은 차원이 [1:2, 1](2차원이고 2행 1열)로 표시되어 있는 점이 다르다.
is.factor, is.numeric (숫자 벡터), is.character(문자열 벡터), is.matrix, is.data.frame 등의 ‘is.\*’ 형태의 함수들을 사용해 데이터의 타입을 확인 할 수 있다. 다음 코드에 몇가지 예를 보였다.
# 9. 타입 변환
타입간의 변환은 각 타입에 인자로 변환할 데이터를 넘기거나, ‘as.\*’ 종류의 함수를 사용하여 수행할 수 있다.
다음은 행렬을 data.frame()의 인자로 넘겨 데이터 프레임으로 형변환 하는 예이다.
  ~~~ R
> (x <- data.frame(matrix(c(1:4), ncol=2)))
  X1 X2
1  1  3
2  2  4
~~~
다음은 리스트를 데이터 프레임으로 변환한 예이다.
  ~~~ R
> data.frame(list(x=c(1,2),y=c(3,4)))
  x y
1 1 3
2 2 4
#또는 as.numeric, as.factor, as.data.frame, as.matrix 등의 함수를 사용한 형 변환이 가능하다. 예를들어 다음은 문자열 벡터를 Factor로 변환했다가 다시 숫자형 벡터로 변환하는 코드이다.
  > as.factor(x)
[1] m f
Levels: f m
> as.numeric(as.factor(x))
[1] 2 1
~~~

[^1]: =는 경우에 따라 사용될 수 없는 경우가 있다.
[^2]: 이는 \|\|와 \|도 마찬가지이다.
[^3]: 따라서 A && B형태의 코드가 있을때 A가 만약 TRUE라면 B도 평가하지만 A가 FALSE라면 B를 평가하지 않는다.
[^4]: 만약 다른 타입의 데이터를 섞어서 벡터에 저장하면 이들 데이터는 한가지 타입으로 자동 형변환 된다.
[^5]: 중첩된 구조가 필요하다면 뒤에서 다룰 리스트(List)를 사용해야한다
[^예약어]: 모름ㅎㅎ. 대충 R실행시 선언된 변수로 직접 수정할 수는 없는 걸로 추정됨. 공부 더해서 설명 추가 예정
[^6]: 이때, 인덱스는 다른 언어와 달리 1부터 시작한다.
[^7]: end에 위치한 요소 포함
[^8]: NROW()는 nrow()의 변형 (대문자임에 주의!)
[^9]: 값을 가져오기 위해서는 ‘[[인덱스]]’ 의 형태로 적어야지 ‘[인덱스]’로 해서는 안된다.
[^10]: 이 때, 인덱스는 벡터의 경우와 마찬가지로 1부터 시작한다.
