---
title: "R 기초정리"
category:
  - R
tag:
  - note
---
1. 목차
{:toc}

1. # 데이터타입
    1. ## 변수
첫글자는 문자 또는 ‘.’ 으로 시작해야한다.<br>
변수에 값을 할당할때는 <- 또는 <<- 또는 =[^1]를 사용한다.
    1. ## 스칼라
R의 기본형은 벡터이므로 스칼라는 길이 1의 벡터로 볼 수 있다.<br>
그러나 실제로는 편하게 스칼라 자료라고 생각해도 큰 문제는 없다.
        1. ### 숫자
정수, 부동 소수 등이 자연스럽게 지원된다
        1. ### NA (결측치)
만약 데이터에 값이 존재하지 않는다면 NA로 표시할 수 있다.<br>
예를들어 4명의 시험점수가 있을 때 그 점수가 각각 80, 90, 75 이지만 4번째 사람의 점수를 모른다면 NA로 표현한다.
is.na() 함수로 확인할 수 있다
        1. ### NULL
NULL은 NULL객체를 뜻하는데, 변수가 초기화 되지 않은 경우 등에 사용할 수 있다. 이는 NA와 구분하여 생각해야한다.<br>
어떤 변수에 NULL이 할당되었는지는 is.null()을 사용하여 판단할 수 있다.
        1. ### 문자열
R은 C 등의 언어에서 볼 수 있는 한개 문자에 대한 데이터 타입은 없다. 대신 문자열로 모든 것을 처리한다.<br>
문자열은 ‘this is string’ 또는 “this is string” 과 같이 어느 따옴표로 묶어도 된다.
        1. ### 진리값
__1) TRUE, T는 모두 참값을 말한다.  FALSE, F 는 거짓을 말한다.__  
좀 더 엄밀히 말하면 TRUE, FALSE는 예약어(reserved words)이며 T, F는 각각 TRUE와 FALSE로 초기화된 전역 변수이다.  
따라서 다음과 같이 T에 FALSE를 할당하는 것이 가능한 반면 TRUE에는 FALSE를 할당할 수 없다.
~~~ R
> (T <- FALSE)
[1] FALSE
> (TRUE <- FALSE)
Error in TRUE <- FALSE : 대입에 유효하지 않은 (do_set) 좌변입니다
~~~
__2) 논리연산자에는 AND, OR, NOT 3가지가 있다.__  
AND연산자 : &&, &  
OR연산자 : ||, |  
NOT연산자 : !  
&&와 &는 같은 AND연산자지만 boolean이 저장된 벡터끼리의 연산에서는 차이점이 있다.[^2]
&는 벡터의 각 원소간 AND연산을 한다.  
반면 &&은 벡터의 맨 앞의 원소만 AND연산을 한다.  
~~~ R
>  c(TRUE, FALSE, TRUE) & c(TRUE, FALSE, FALSE)
[1]  TRUE FALSE FALSE
>  c(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE)
[1] TRUE
~~~
또한 &&, || 는 short-circuit을 지원한다.[^3]
    1. ## 요인(Factor)
__범주형(Categorical) 변수__ 를 위한 데이터 타입.  
Factor 변수는 nlevels()로 범주의 수를 구할 수 있고, levels()로 범주 목록을 알 수 있다.  
~~~ R
> (sex <- factor("m", c("m", "f")))
[1] m
Levels: m f
> nlevels(sex)
[1] 2
> levels(sex)
[1] "m" "f"
> levels(sex)[1]
[1] "m"
> levels(sex)[2]
[1] "f"
~~~
Factor 변수에서 level의 값을 직접적으로 수정하고자한다면 levels()에 값을 할당하면 된다.  
~~~ R
> (levels(sex) <- c('male', 'female'))
[1] "male"   "female"
~~~
factor()는 기본적으로 데이터에 순서가 없는 명목형 변수(Nominal)를 만든다. 만약 범주형 데이터지만 ‘나쁨, 조금 나쁨, 보통, 조금 좋음, 아주 좋음’ 등과 같이 순서가 있는 값일 경우는 순서형(Ordinal) 변수로 만들기 위해 ordered()를 사용하거나 factor() 호출시 ordered=TRUE를 지정해준다.  
~~~ R
> c('a','b','c')
[1] "a" "b" "c"
> ordered(c('a','b','c'))
[1] a b c
Levels: a < b < c
> factor(c('a','b','c'), ordered=TRUE)
[1] a b c
Levels: a < b < c
~~~
앞서와 달리 Levels에 순서가 < 로 표시되어있음을 볼 수 있다.
    1. ## 벡터(Vector)
        1. ### 벡터의 정의
벡터는 다른 프로그래밍 언어에서 흔히 보는 배열의 개념으로, 다음과 같이 c() 안에 원하는 인자들을 나열하여 정의한다.  
~~~ R
> (x<-c(1,2,3,4,5))
[1] 1 2 3 4 5
~~~
벡터의 특징  
1) 나열하는 인자들은 __한가지 유형__ 의 스칼라 타입이어야한다.[^4]
2) 벡터는 중첩될 수 없다. 따라서 벡터 안에 벡터를 정의하면 이는 단일 차원의 벡터로 변경된다.[^5]
3) 숫자형 데이터의 경우 start:end 형태로 시작값부터 끝값까지의 값을 갖는 벡터를 만들 수 있다. 또는 seq(from, to, by) 형태역시 가능하다.
~~~ R
> x <- 1:10
> seq (1 , 10 , 2)
[1] 1 3 5 7 9
> seq_along(c('a','b','c')) #seq along()은 인자로 주어진 데이터의 길이만큼 1, 2, 3, ..., N 으로 구성된 벡터를 반환한다.
[1] 1 2 3
> seq_len(3) #seq len()은 N값이 인자로 주어지면 1, 2, ..., N으로 구성된 벡터를 반환한다.
[1] 1 2 3
> x <- c (1 , 3 , 4) #벡터의 각 셀에는 이름을 부여할 수 있다. names()에 원하는 이름을 벡터로 넘겨주면 된다.
> names(x) <- c("kim","seo","park")
~~~




3.2 벡터내 데이터 접근
벡터는 [ ] 안에 인덱스를 적어서 각 요소를 가져올 수 있다. 이때, 인덱스는 다른 언어와 달리 1 로 시작한다.
또 ‘-인덱스’ 와 같이 음수의 인덱스를 사용해 특정 요소만 제외할 수도 있다.
벡터의 여러 위치에 저장된 값을 가져오려면 ‘벡터명[색인 벡터]’의 형식을 사용한다
‘x[start:end]’ 를 사용해 start부터 end까지 (end에 위치한 요소 포함)의 데이터를 볼 수도 있다.
  > x <- c("a","b","c")
  > x[1]
  [1] "a"

    > x[-2]
    [1] "a" "c"
    > x[c(1,3)]
    [1] "a" "c"
    > x[1:2]
    [1] "a" "b"
  벡터의 각 셀에 names()를 사용해 이름을 부여해 두었다면, 이 이름을 사용해 데이터를 접근할 수 있다.
    > names ( x ) <- c ( " kim " , " seo " , " park " )
    > x [ c ( " kim " , " park " ) ]
    kim park
    3 4
  벡터에 부여된 이름만 보려면 이름을 부여할 때와 마찬가지로 names()를 사용한다. 다음은 벡터의 두번째 요소에 부여된 이름이 “seo” 임을 보여준다.
    > names ( x ) [2]
    [1] " seo "
  벡터의 길이는 length() 또는 NROW() (대문자임에 주의!) 를 통해 알 수 있다.
  본래 nrow()는 행렬(Matrix) 의 행의 수를 알려주는 함수이지만,
  nrow()의 변형인 NROW()는 인자가 벡터인경우 벡터를 n행 1열의 행렬로 취급해 길이를 반환한다.
    > x <- c("a","b","c")
    > length ( x )
    [1] 3
    > nrow ( x ) # nrow ()는 행렬만가능
    NULL
    > NROW ( x ) # NROW ()는 벡터와행렬모두사용가능
    [1] 3

  3.3 벡터 연산
  %in% 연산자는 어떤 값이 벡터에 포함되어있는지를 알려준다
    > " a " %in% c("a","b","c")
    [1] TRUE
    > " d " %in% c("a","b","c")
    [1] FALSE
  벡터를 집합(set)으로 취급해 집합간 합집합, 교집합, 차집합을 계산할 수 있다.
    > setdiff(c("a","b","c"), c("a","d"))
    [1] " b " " c "
    > union(c("a","b","c"), c("a","d"))
    [1] " a " " b " " c " " d "
    > intersect(c("a","b","c"), c("a","d"))
    [1] " a "
  집합간 비교는 setequal()을 사용한다.
    > setequal(c("a","b","c"), c("a","d"))
    [1] FALSE
    > setequal(c("a","b","c"), c("a","b","c","c"))
    [1] TRUE

  3.4 seq
  1부터 31까지의 숫자를 저장한 벡터를 표현하려면 c(1, 2, 3, ..., 31)과 같이 숫자를 모두 나열해야한다. 이러한 번거로운 일을 피하기 위해 seq()함수를 쓸 수 있다. seq(시작값, 마지막값, 증가치)의 형태로 호출하면 된다. 이때 증가치는 생략가능하다.
    > seq(1,5)
    [1] 1 2 3 4 5
    > seq(1,5,2)
    [1] 1 3 5
  보다 짧게 표현하려면 시작값:마지막값 형태로 적어도 된다.
    > 1:5
    [1] 1 2 3 4 5

  3.5 rep
  특정 값들이 반복된 벡터를 손쉽게 만드려면 rep()를 사용한다. 다음은 1, 2를 총 5회 반복한 벡터를 만드는 예이다.
    > rep (1:2 , 5)
    [1] 1 2 1 2 1 2 1 2 1 2
  이와 달리 1이 5회, 2가 5회 반복된 벡터를 만들기위해서는 다음과 같이 하면된다.
    > rep (1:2 , each =5)
    [1] 1 1 1 1 1 2 2 2 2 2

  4 리스트(List)
  리스트는 다른언어에서 흔히 보는 해싱 또는 딕셔너리에 해당하며, (키, 값) 형태의 데이터를 담는 연관 배열(associative array)이다
  4.1 리스트의 정의
  리스트는 list(키=값, 키=값, ...) 형태로 데이터를 나열해 정의한다.
    > x <- list ( name = " foo " , height =70)
    > x
    $ name
    [1] " foo "
    $ height
    [1] 70
  이 때 각 값이 반드시 스칼라일 필요는 없다. 다음처럼 벡터를 저장할 수도 있다.
    > x <- list ( name = " foo " , height = c (1 , 3 , 5) )
    > x
    $ name
    [1] " foo "
    $ height
    [1] 1 3 5
  이처럼 리스트에는 다양한 값들을 혼합해서 저장할 수 있다. 따라서 리스트 안에 리스트를 중첩하는 것이 가능하다.
    > list ( a = list ( val = c (1 , 2 , 3) ) , b = list ( val = c (1 , 2 , 3 , 4) ) )
    $a
    $a$ val
    [1] 1 2 3
    $b
    $b$ val
    [1] 1 2 3 4

  4.2 리스트내 데이터 접근
  앞에서 본바와 같이 리스트를 출력해보면 ‘$키’ 형태로 각 키들이 나열된다. 데이터는 ‘리스트 변수명$키’와 같이 접근한다. 또는 각 요소를 순서대로 ‘리스트변수[[인덱스]]’와 같이 접근할 수도 있다.
    > x <- list ( name = " foo " , height = c (1 , 3 , 5) )
    > x$ name
    [1] " foo "
    > x$ height
    [1] 1 3 5
    > x [[1]]
    [1] " foo "
    > x [[2]]
    [1] 1 3 5
  주의할점은 값을 가져오기 위해서는 ‘[[인덱스]]’ 의 형태로 적어야지 ‘[인덱스]’로 해서는 안된다는 점이다. ‘[인덱스]’의 형태는 각 값이 아니라 ‘(키, 값)’ 을 담고 있는 서브 리스트를 반환한다. 예를들어 다음의 코드를 보자.
    > x [1]
    $ name
    [1] " foo "
    > x [2]
    $ height
    [1] 1 3 5
  보다시피 x[1]는 ‘(name, foo)’ 를 갖고 있는 리스트를 반환한다.


  5 행렬(Matrix)
  벡터와 마찬가지로 행렬에는 한가지 유형의 스칼라만 저장할 수 있다.
  5.1 행렬의 정의
  행렬은 matrix( )를 사용해 표현한다. 다음은 1, 2, 3, 4, 5, 6, 7, 8, 9로 구성된 3행 3열의 행렬을 만드는 방법이다.
    > matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , nrow =3)
    > matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , ncol =3)
  행렬값을 나열한뒤 ncol을 사용해 열의수를 지정하거나 nrow를 사용
  해 행의 수를 지정하면 된다. 위 경우에는 행렬값이 좌측 열부터 채워져오는데, 대신 행렬값을
  위쪽 행부터 채우고 싶다면 byrow를 사용한다.
    > matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , nrow =3 , byrow = T )
  행렬의 행과 열에 명칭을 부여하고 싶다면 dimnames()를 사용한다.
    > matrix(c(1,2,3,4,5,6,7,8,9), nrow=3, dimnames=list(c("item1","item2","item3"), c("feature1","feature2","feature3")))
  5.2 행렬내 데이터 접근
  행렬의 각 요소는 ‘행렬이름[행인덱스, 열인덱스]’로 접근할 수 있다. 이 때, 인덱스는 벡터의 경우와 마찬가지로 1부터 시작한다.
    > x <- matrix(c(1,2,3,4,5,6,7,8,9), ncol =3)
    > x[1,1]
  역시 벡터와 마찬가지로 ‘-인덱스’와 같이 표현해 특정 행/열을 제외하거나 ‘시작인덱스:끝인덱스’로 특정 범위의 데이터만 가져올 수도 있다. 만약 특정 행이나 열의 전부를 가져오고 싶다면 행이나 열쪽에는 아무런 인덱스도 기재하지 않으면 된다.
    > x[1:2, ]
  반대로 3행을 제외하는 방법을 쓸 수도 있다
    > x[-3, ]
  또는 인덱스를 벡터에 넣어 나열할 수도 있다. 다음은 1행, 3행, 1열, 3열의 값만 추출하는 경우이다
    > x[c(1,3), c(1,3)]
  만약 dimnames를 통해 행과 열에 이름을 부여했다면 그 이름을 직접 사용할 수도 있다
    > x["item1",]
  5.3 행렬의 연산
  행렬에 스칼라를 곱하거나 나누는 연산은 일반적인 프로그래밍 언어에서 하듯이 * 나 / 를 사용한다.
    > x <- matrix ( c (1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9) , nrow =3)
    > x * 2
    > x / 2
  행렬끼리의 덧셈이나 뺄셈은 + 나 - 를 사용한다.
    > x + x
    > x - x
  행렬 곱은 %*% 를 사용한다.
    > x % * % x
  역행렬은 solve(행렬)로 계산한다.
    > solve ( x )
    > x % * % solve ( x )
  전치행렬은 t()로 구한다.
    > t ( x )
  행렬의 차원은 ncol() 또는 nrow()로 알 수 있다
    > ncol ( x )
    > nrow ( x )

  6 배열
  6.1 배열 정의
  matrix가 2차원 행렬이라면 배열(array)은 n차원 행렬이다. 예를들어 3x4 matrix는 다음과 같이 array를 사용해 표현할 수 있다.
    > matrix (1:12 , ncol =4)
    > array (1:12 , dim = c (3 , 4) )
  이번에는 이 데이터로 2x2x3 차원의 배열을 만들어보자.
    > array (1:12 , dim = c (2 , 2 , 3) )
  6.2 배열 데이터 접근
  행렬의 경우와 유사한 방식으로 각 요소에 접근할 수 있다. 또, 배열의 차원은 dim() 함수를 통해 알 수 있다
    > x <- array (1:12 , dim = c (2 , 2 , 3) )
    > x [1 , 2 , 3]
    > x [ , , 3]
    > dim ( x )

  7 데이터 프레임(Data Frame)
  데이터 프레임은 R에서 가장 중요한 자료형이다. 데이터 프레임은 행렬과 마찬가지의 모습을 하고 있지만 행렬과 달리 다양한 변수, 관측치(observations), 범주 등을 표현하기 위해 특화되어있다.

  data.frame() 을 사용해 정의한다
    > d <- data.frame(x=c(1,2,3,4,5), y=c(2,4,6,8,10))
    > d <- data.frame(x=c(1,2,3,4,5), y=c(2,4,6,8,10), z=c('M','F','M','F','M'))
  만약 이미 정의된 데이터 프레임에 새 열을 추가하고자한다면 ‘$열이름 <- ...’ 과 같은 형식으로 새로운 데이터를 추가할 수 있다.
    > d$v <- c (3 , 6 , 9 , 12 , 15)

  7.2 데이터 프레임 접근
    > d$x
    > d[c(1,3), 2]
    > d[-1, -c(2,3)]
    > d[, c("x","y")]
  컬럼을 1개만 선택했을때는 data.frame의 일반적인 모양인 표 형태가 아닌 벡터처럼 결과가 나온 것을 볼 수 있다. 이는 컬럼의 차원이 1이되면 자동으로 데이터 프레임이 아닌 벡터로 값을 반환하기 때문이다. 이를 피하려면 다음과 같이 drop=FALSE 옵션을 지정한다.
    > d [ , c ( " x " ) , drop = FALSE ]
  str()함수는 R 객체의 내부 구조를 보는데 사용되는 함수로 데이터 프레임을 인자로 받으면 데이터 타입등을 잘 정리해서 한눈에 보기쉽게 나타낸다.
  통상 R에서의 처리는 데이터 프레임을 기본 타입으로 하여 진행되므로 데이터 프레임에 많은 양의 데이터를 저장하게 된다. 이때 만약 단순히 데이터를 저장한 변수명을 입력하면 전체 데이터가 모두 출력되므로 데이터의 일부를 읽어보기가 어렵다. 이 경우 쉽게 데이터의 제일
  앞부분만 살펴보는데 head()를 사용할 수 있다.
  데이터 프레임의 행 이름, 열 이름은 각각 rownames(), colnames() 함수로 지정할 수 있다.
    > x <- data.frame (1:3)
    > colnames ( x ) <- c ('val ')
    > rownames ( x ) <- c ('a', 'b', 'c')
  또는 names()를 사용해도 colnames()와 같은 결과를 얻는다.
  주어진 값이 벡터에 존재하는지를 판별하는 %in% 연산자를 이용하면 특정 열만 선택하는 작업을 보다 손쉽게 할 수 있다.
    > ( d <- data.frame ( a =1:3 , b =4:6 , c =7:9) )
    > d [ , names ( d ) %in% c ( " b " , " c " ) ]
  위 코드에서 첫 줄의 (d <- data.frame...) 에는 명령의 처음과 끝에 괄호가 사용되었다. 이와 같은 방식으로 명령을 기술하면 해당 명령을 수행함과 동시에 결과값(여기서는 d)를 출력하는 작업까지 동시에 하게 된다
  반대로 ! 연산자를 사용해 특정 값들만 제외해서 열을 선택할 수도 있다
    > d [ , ! names ( d ) %in% c ( " a " ) ]

  8 타입 판별
  데이터를 처리하기 위해 여러 함수를 호출하다보면 반환된 결과의 타입이 무엇인지 분명하지 않을때가 있다. 이때는 다음과 같이 class()를 사용할 수 있다.
  또는 str()문으로도 확인해 볼수 있다.
  벡터와 행렬의 결과가 유사해보이지만 벡터의 경우 차원이 [1:2](1차원에 값이 2개)라고 표시되어있는 반면, 행렬은 차원이 [1:2, 1](2차원이고 2행 1열)로 표시되어 있는 점이 다르다.
  is.factor, is.numeric (숫자 벡터), is.character(문자열 벡터), is.matrix, is.data.frame 등의 ‘is.*’ 형태의 함수들을 사용해 데이터의 타입을 확인 할 수 있다. 다음 코드에 몇가지 예를 보였다.

  9 타입 변환
  타입간의 변환은 각 타입에 인자로 변환할 데이터를 넘기거나, ‘as.*’ 종류의 함수를 사용하여 수행할 수 있다.
  다음은 행렬을 data.frame()의 인자로 넘겨 데이터 프레임으로 형변환 하는 예이다.
    > x <- data.frame ( matrix ( c (1 , 2 , 3 , 4) , ncol =2) )

  다음은 리스트를 데이터 프레임으로 변환한 예이다.
    > data.frame ( list ( x = c (1 , 2) , y = c (3 , 4) ) )
  또는 as.numeric, as.factor, as.data.frame, as.matrix 등의 함수를 사용한 형 변환이 가능하다. 예를들어 다음은 문자열 벡터를 Factor로 변환했다가 다시 숫자형 벡터로 변환하는 코드이다.
    > x <- c ( " m " , " f " )
    > as.factor ( x )
    > as.numeric ( as.factor ( x ) )
**

[^1]: =는 경우에 따라 사용될 수 없는 경우가 있다.
[^2]: 이는 ||와 |도 마찬가지이다.
[^3]: 따라서 A && B형태의 코드가 있을때 A가 만약 TRUE라면 B도 평가하지만 A가 FALSE라면 B를 평가하지 않는다.
[^4]: 만약 다른 타입의 데이터를 섞어서 벡터에 저장하면 이들 데이터는 한가지 타입으로 자동 형변환 된다.  
[^5]: 중첩된 구조가 필요하다면 뒤에서 다룰 리스트(List)를 사용해야한다
