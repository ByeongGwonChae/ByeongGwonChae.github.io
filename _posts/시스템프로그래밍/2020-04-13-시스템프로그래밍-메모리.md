---
title: "시스템프로그래밍-메모리"
category:
  - system programming
tag:
  - system programming
  - linux
toc: true
toc_sticky: true
---

메모리를 순차적으로 접근할 것인지 아니면 랜덤으로 접근할 것인지 메모리 조언 기능을 사용하는 방법에 따라서도 성능 차이가 발생한다. 그래서 시스템 프로그래머들은 메모리를 효율적으로 다루기 위해 지역성의 원리(Principle of Locality)에 최대한 충실하게 메모리를 다루려고 노력한다.

그러나 지역성의 원리나 메모리 조언 같은 기능을 제대로 이해하기 위해서는 먼저 메모리를 나누는 기준부터 알아야만 한다.

메모리를 나누는 기준은 여러 가지가 있는데 스코프에 따라 프로그램에 속한 가상 메모리, 시스템 영역에 속하는 IPC의 공유 메모리 등으로 나눌 수도 있고, 쓰임새에 따라 각종 처리를 위해 저장해야 하는 데이터 영역, 실행 코드를 담은 텍스트 영역 등등 다양하게 나눌 수 있다.

그래서 이번 장에서는 시스템 프로그래밍을 하는데 꼭 필요한 프로세스의 다양한 메모리와 적재되는 위치, 기능에 대해서 간략하게 다룰 것이다.

# 프로세스의 메모리

프로그램은 실행을 위해서 메모리에 로딩되어야만 하는데 기능에 따라 몇 가지로 나눌 수 있다. =가장 기초적인 분류로서 4가지가 있다.

- 텍스트(.text)

일반적으로 프로그래므이 실행 코드가 존재하는 영역. 소스 코드를 컴파일해서 만들어진 기계어 코드가 실행을 위해 적재되는 곳을 의미한다.

가끔은 특수한 때에만 데이터 영역에 코드를 포함하여 컴파일할 수도 있지만 흔한 일은 아니다. 보통 보안 관련(security&cracking)프로그래밍이 이런 기법을 사용한다.

- 데이터

데이터 영역은 주로 전역 변수나 정적 심볼들이 사용되는 영역인데, 사용되는 용처에 따라서 세분화하고 더 많은 영역으로 나눌 수도 있지만, 기본적으로 알고 있어야 하는 3가지 부분은 다음과 같다.

데이터 영역의 분류

|.rodate|읽기 전용으로 초기화되는 영역|
|.data|일기/쓰기가 가능한 영역으로 초기화되는 영역|
|BSS|초기화되지 않는 영역|

.rodata는 const로 선언되는 변수들이 들어간다. 그 외에 시스템에서 사용된 각종 문자열 등이 이곳에 위치한다. 예를 들어 printf문의 포맷 스트링이나 상수 문자열 등이 이에 해당한다.

.data영역은 전역 변수 중에 초기값을 가지는 경우이다.

BSS(Block Started by Symbol) 영역이라고 불리는 곳은 초기화되지 않은 전역 변수나 static으로 선언된 변수가 여기에 위치한다. BSS 영역은 C의 startup 함수가 main 함수를 실행하기 전에 0(NULL)으로 초기화를 하게 된다.

- 스택 (stack)

스택 영역은 로컬 자동 변수, 즉 임의로 메모리를 잡지 않아도 함수의 시작에서 자동으로 생성되고 파기되는 변수를 말한다. 일반적으로 함수나 블록 내에서 사용되는 auto 변수를 의미한다.

C 언어에서 auto 지시어는 생략하므로 블록에서 "int x"라고 선언한다면 여기에 해당한다. 스택 공간의 자동 변수는 해당 스코프 영역을 벗어나면 스택의 프레임에서 해제되므로 자연적으로 파기된다.

- 힙 (heap)

힙은 malloc이나 calloc 같은 메모리 할당 함수를 사용하여 얻는 공간으로 프로세스 어디서든 접근 가능하다. 또한, 프로세스가 종료하지 않는 한 자동으로 파괴되지 않으므로 할당과 해제, 경계면의 검사를 프로그래머가 전적으로 해야만 한다. 보통은 메모리 반환을 체크해주는 유틸리티를 이용하여 검사하는 경우가 많다.

## 변수의 메모리 위치와 특성

다음 표는 전역 변수의 선언 방식에 따라 어떤 메모리에 적재되는지 보여주고 있다. 이와 같이 변수의 선언되는 위치나 형태, 한정어(qualifier)에 따라서 다른 공간에 적재된다는 점을 알아두도록 하자.

전역 변수들의 형태에 따른 메모리 위치

|int num;|bss에 위치|
|int num=1;|data에 위치|
|char str[] = "hello";|data에 위치 (읽기/쓰기 가능)|
|char *p_str = "hello";|문자열 hello는 .rodata에, p_str 포인터 변수는 data에 위치|
|const char str[] = "hello";|문자열 hello는 .rodata에, str 변수는 data에 위치|
|static int i_val;|bss에 위치|

그러면 메모리의 종류를 알앗으니 이번에는 메모리의 성능과 용량 제한에 대해 살펴보자. 우선 스택과 힙의 차이부터 보도록 하자.

일반적으로 스택은 할당과 해제가 매우 빠르다고 알려졌다. 그러나 실제로는 스택은 할당만 할 뿐 해제를 하지 않는다. 스택은 필요에 따라 할당을 하면서 계속 키워나가는데 사용 후 반환해도 여전히 스택 크기를 계속 유지하면서 재사용하게 된다. 이런 특징 때문에 프로세스가 매우 큰 스택 메모리를 한 번이라도 사용하게 되면 프로세스가 종료하기 전까지는 메모리가 낭비될 수 있는 요지가 있다. 그래서 유닉스 계열에서는 스택 크기를 제한하는 설정이 존재한다.

./ulimit -a의 stack size로 확인한 스택 제한이 10240 kbytes의 제약이 있음을 알수 있다. 이 한계 수치를 넘어가려고 하면 시스템은 프로세스를 종료시켜 버린다. 이를 확인하기 위해 다음 코드를 실행해보면 된다.

stack_heap.c

스택 크기가 10MiB로 지정되었고, 위의 함수를 11번 재귀호출한다면, 즉, exhaust)stack(11)로 호출하면 SEGV(segmentation violation) 오류가 발생하게 된다.

SEGV 오류로 발생하는 이유는 정해진 메모리 세그먼트를 벗어났기 때문이다. 그렇다면 1MiB짜리 전역 변수도 같이 사용된다면 영향을 미칠까? 정답은 "No"다. 전역 변수는 앞서 언급한 대로 .data나 .bss영역 같은 곳에 들어가기 때문에 스택과는 별도로 관리된다.

그러면 스택의 크기는 적당한 것인지 고민해봐야 한다.일반적으로 10MiB이상의 스택을 소모하는 경우는 거의 없지만, 스레드를 사용하면 동시에 함수가 실행될 수도 있을 테니 의구심을 가질 수 있을 것이다. 하지만 안심해도 좋다. 스레드의 경우라면 스레드의 별도 스택 공간과 크기 설정을 가지므로 위의 설정과는 다르게 작동한다. 따라서 main에서 시작하는 함수와 재귀 함수 그리고 라이브러리들의 스택 크기를 신경 써야 한다.

### 스레드

스레드의 스택 공간은 별도의 메모리 공간을 할당받아서 관리된다. 예로 리눅스의 경우 스레드는 힙 공간에 별도의 가상 스택을 만들게 되므로 프로세스의 스택과는 연관이 없다.

## VLA 배열

스택은 빠르지만, 정적인 크기로 선언되기 때문에 데이터의 크기가 가변인 경우 힙으로 대체되는 경우가 많았다. 하지만, 최근 C99 표준(ISO/IEC-9899:1999)에 추가된 VLA(Variable Length Array)는 가변 길이로 배열을 선언할 수 있도록 하였다.

VLA를 사용하면 힙처럼 메모리 누수를 신경 써서 할당과 해제를 주의 깊게 살필 필요도 없고 속도 면에서도 뛰어나기 때문에 최근에는 많이 사용되고 있다.

다만, C99는 해당 표준을 지원하는 임플리먼테이션을 사용해야 한다. gcc는 3.0부터 이를 지원하기 시작했으니 2011년도에 사용되는 대부분의 gcc 4.x대에서는 기본으로 지원하고 있다. 현재 시스템에서 gcc의 C99 표준 지원 현황을 보고자 한다면 http://gcc.gnu.org/c99status.html에섭 볼 수 있다.

VLA의 주의할 점으로는 struct, union의 멤버로는 선언될 수 없으며 전역 변수도 안된다. 즉 블록이나 함수 스코프 안에 존재해야 한다. 따라서 static이나 extern 같은 경우나 const, volatile로 선언한 경우에도 VLA를 사용할 수 없다. 왜 그런지는 앞서 각종 변수가 존재하는 위치에 대해 생각해보면 이해가 갈 것이다.

앞서 다뤘던 메모리들의 배치되는 위치는 실행 파일을 분석하면 알 수 있는데 objdump나 readelf를 사용하면 된다. 예를 들어 "objdump -x 실행파일"로 명령하면 실행 파일의 헤더를 분석해서 보여준다.

# 메모리 락(memory lock)

이 기능은 실시간 확장 표준에서 추가되었으며 페이징 락(paging lock) 기능을 제공한다.

페이징 : 가상 메모리를 효율적으로 사용하기 위해 디스크의 일부와 메모리를 교환(swap)하는 것을 말한다. 디스크로 저장하는 것을 paging out, 그 반대롤 불러오는 것을 paging in이라고 한다.

페이지 락 : 메모리 페이지에 대해 페이징을 금지하는 기능. 즉, 해당 메모리 공간을 항상 램에만 있도록 강제하는 것을 의미한다. 그러면 이 기능은 어디에 활용도가 있을까?

1. 실시간 처리가 중요한 어플리케이션이 메모리에 접근할 때 지연을 방지할 수 있게 된다. 일반적으로 프로세스에서 사용하는 가상 메모리는 운영체제의 정책에 의해 디스크로 스왑 될 수 있다. 그러나 페이징이 발생하면 실제 처리는 I/O 요청이 끝날 때까지 지연된다. 이런 문제는 실시간성을 중시하는 고성능의 어플리케이션에 대해서 심각한 위협이 될 수 있다. 따라서 메모리 락을 이용해서 페이징을 금지해야 할 필요가 있다.

1. 보안이 중요한 데이터가 디스크에 저장되는 것을 방지할 수 있게 된다. 예를 들어 보안용 암호나 키, 테이블 같은 데이터가 페이징되어 디스크에 스왑 아웃되면 프로세스가 종료한 뒤에도 디스크에 쓰레기 데이터로 남아 있을 가능성이 있다. 이런 때 해킹을 통해 외부에 노출될 가능성도 존재하므로 보안 데이터는 메모리 락을 이용해서 프로세스 종료화 함께 사라지도록 할 필요가 있다.

메모리 락 관련 함수

|mlock|특정 위치의 메모리 페이지를 잠근다.|
|mlockall|현재 프로세스의 모든 페이지를 잠근다.|
|munlock|특정 위치의 메모리 페이지 잠금을 해제한다.|
|munlockall|모든 페이지 잠금을 해제한다.|

~~~ c
int mlock(const void *addr, size_T len);
int mlockall(int flags);
~~~

mlock은 addr 주소 위치부터 len만큼의 공간에 대해 메모리 락을 설정한다. 이 함수를 사용할 때 주의할 점은 addr가 페이지 크기의 경계에서 시작되도록 하는 것이다. 왜냐하면, 대부분 아키텍처에서 페이지 크기의 경계, 즉 페이지 크기의 배수가 아닌 주소라면 오류를 발생시킬 수 있기 때문이다.

mlockall은 특정 주소 위치를 지정하지 않고 프로세스의 메모리 전체에 대해 메모릴 락을 설정하는 함수다. 단 flags를 지정하여 메모리 락의 정책을 결정할 수 있다. 지정 가능한 플래그는 다음과 같이 2개가 제공되며 bitwise-inclusive OR로 결합할 수 있다.

mlockall의 flags 인수

|MCL_CURRENT|현재 프로세스에 할당된 페이지 전체에 대해 메모리 락을 설정한다.|
|MCL_FUTURE|앞으로 할당되는 모든 페이지에 대해 메모리 락을 설정한다.|

mlockall은 메모리맵(mmap), 공유 메모리, 힙, 스택 등 모든 공간에 대해 메모리 락을 설정하므로 대부분 경우에는 시스템 한계(ulimit -l로 확인)를 초과하여 ENOMEM에러로 실패할 가능성이 크다. 다라서 특이한 경우가 아니라면 mlockall은 사용하지 않는 것이 좋다. 그러나 매우 높은 실시간성을 가져야 하는 프로세스이고 메모리 사용이 크지 않은 경우라면 mlockall로 프로세스가 사용하는 전체 메모리에 대해 페이징 금지를 거는 때도 있다.

메모리 락은 같은 주소 공간에 대해서 여러 번 호출한다고 하더라도 중복되어 잠금이 걸리지는 않는다. 따라서 mlock으로 서로 겹치는 주소 공간을 설정했거나 mlockall을 여러 번 호출했다고 하더라도 메모리 락은 중복된 부분을 다시 잠그거나 하지 않으므로 빡빡하게 크기를 계산하거나 할 필요는 없다.

~~~ c
int munlock(const void *addr, size_t len);
int munlockall(void);
~~~

메모리 락을 해제할 때는 해제할 주소를 지정할 수 있는 munlock과 현재 설정된 메모리 락 전체를 해제하는 munlockall이 있다. 참고로 앞서 메모리 락이 중복되지 않는 것처럼 여러 번 메모리 락을 설정했다고 하더라도 같은 주소 공간에 대해서는 여러 번 munlock을 호출할 필요가 없다. 마찬가지로 munlockall도 한 번만 호출하면 모든 메모리 락은 해제된다.

memory_lock.c

메모리 락은 시스템의 자원이나 한계에 위협적인 설정이 될 수도 있기 때문에 수퍼유저의 권한으로 실행하거나 특정 능력(capabilities)을 설정한 경우에 가능하다. 따라서 일반적으로 mlock을 사용하는 프로그램은 sudo나 setcap으로 능력을 설정하는 경우가 많다.

다음은 memory_lock 예제 프로그램의 실행 파일에 CAP_IPC_LOCK 능력을 부여하여 일반 유저의 권한으로 mlock이 가능하도록 하는 예이다.

```
#setcap cap_opc_lock=ep ./memory_lock
#getcap ./memory_lock
./memory_lock = cap_ipc_lock+ep
```






