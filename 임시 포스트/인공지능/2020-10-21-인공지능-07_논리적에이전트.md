---
title: "인공지능-07. 논리적 에이전트"
category:
  - AI
tag:
  - AI
toc: true
toc_sticky: true
---

이번 장에서는 복잡한 세계의 표현을 형성할 수 있고 추리 공정을 이용해서 세계에 대한 새로운 표현들을 유도할 수 있으며 그러한 새 표현들을 이용해서 다음에 할 일을 연역할 수 있는 에이전트를 설계한다.

지식 기반 에이전트(knowledge-based agent) : 지식의 내부 표현(representation)들에 작용하는 추론(reasoning) 공정들을 사용하는 에이전트.

3~4장의 문제 해결 에이전트들도 지식을 알지만, 그 지식은  아주 제한적이고 유연하지 않다.

부분 관찰 가능 환경에서 에이전트가 현재 상태에 관해 아는 것을 표현하는 유일한 방식은 모든 가능한 구체적 상태들을 나열하는 것뿐이다. 커다란 환경에서는 그런 표현 바식이 비현실적일 확률이 아주 높다.

6장에서는 상태를 변수에 값을 부여하는 배정들로 표현한다는 착안을 소개했다. 이는 올바른 방향으로의 한 걸음이다. 그런 표현을 사용하면 에이전트의 일부 요소들이 영역 독립적 방식으로 작동하게 만들 수 있고, 좀 더 효율적인 알고리즘이 가능해진다.

이번 장과 이후의 장들에서는 이 한걸음을, 말 그대로 그 논리적 귀결로 연장한다. 즉, 논리(logic)를 지식 기반 에이전트를 지원하는 표현들의 일반적 부류(class)로 취급한다. 그런 에이전트는 정보를 다양한 목적에 맞게 조합 및 재조합할 수 있다. 이러한 공정은 눈앞의 이익과는 상당히 동떨어진 것일 수 있다. 지식 기반 에이전트는 명시적으로 서술된 목표의 형태로 새 과제들을 받을 수 있으며, 환경에 대한 새로운 지식을 제공받거나 스스로 습득해서 경쟁력을 빠르게 갖출 수 있으며, 환경의 변화에 적응하거나 유관 지식을 갱신할 수 있다.



# 지식 기반 에이전트

7.1에서는 지식 기반 에이전트의 전반적인 설계를 살펴본다.

- 지식 기지(knowledge base, KB) : 문장들의 집합. 지식 기반 에이전트의 핵심 구성요소.
- 문장(sentence) : 지식 표현 언어(knowledge representation language)로 표현되며, 세계에 대한 어떤 단언(assertion)을 나타낸다. 일부 문장에는 공리(axiom)라는 이름을 붙여서 명예를 부여한다.
- 공리(axiom) : 다른 어떤 문장에서 유도된 것이 아닌, 그 자체로 존재하는 문장.

- TELL : 지식 기지에 새 문장을 추가하는 방법
- ASK : 지식 기지에 있는 문장을 질의하는 방법

추리(inference) : 기존 문장(들)에서 새 문장을 이끌어내는 공정.

추리는 누군가가 ASK 연산으로 지식 기지에 뭔가를 지의했을 때 그 답이 반드시 이전에 지식 기지에 알려준 (TELL 연산) 어떤 지식을 따른다는 요구조건을 만족해야 한다. 

배경지식(background knowledge) : 초기에 지식 기지에 있는 문장

↓지식 기반 에이전트 프로그램의 큰 틀.

```py
def KBAgentProgram(kb):
    """
    [Figure 7.1]
    A generic logical knowledge-based agent program.
    """
    steps = itertools.count()

    def program(percept):
        t = next(steps)
        kb.tell(make_percept_sentence(percept, t))  # 에이전트가 받은 지각을 지식 기지에 알려준다(TELL).
        action = kb.ask(make_action_query(t))       # 에이전트 프로그램은 자신이 수행할 동작을 지식 기지에 묻는다(ASK). (이 질의의 답을 구하는 과정에서 세계의 현재 상태와 가능한 동작열들의 결과들에 관해 상당한 양의 추론이 수행될 수 있다.)
                                                    
        kb.tell(make_action_sentence(action, t))    # 에이전트 프로그램은 자신이 선택한 동작을 지식 기지에 알려준(TELL) 후, 그 동작을 수행한다.
        return action

    def make_percept_sentence(percept, t):  # 에이전트가 특정 시간에 특정 지각을 받았음을 단언하는 문장을 구축한다.
        return Expr('Percept')(percept, t)

    def make_action_query(t):  # 현재 시간에 에이전트가 수행할 동작을 묻는 문장을 구축한다.
        return expr('ShouldDo(action, {})'.format(t))

    def make_action_sentence(action, t):  # 그 동작을 에이전트가 채택했음을 단언하는 문장을 구축한다.
        return Expr('Did')(action[expr('action')], t)

    return program
```
이 프로그램은 지식 수준(knowledge level)에서의 서술을 준수한다. 그러한 수준에서 개발자는 에이전트가 알고 있는 것과 에이전트의 목표들만 지정하면 에이전트의 행동을 바로잡을 수 있다.

구현 수준(implementation level)






# 웜푸스 세계

7.2에서는 간단한 새 환경인 웜푸스 세계를 소개하고, 지식 기반 에이전트의 작동 방식을 기술적인 세부사항 없이 개괄한다.





# 논리

7.3에서는 논리의 일반적인 원리들을 설명한다.

이번 절에서는 논리적 표현과 추론의 근본 개념들을 개괄한다. 이번 절에서 살펴볼 개념들은 특정 형태의 논리(명제 논리, 1차 논리 등등)와는 독립적이다. 따라서 특정 논리 형태의 기술적 세부사항은 다음 절로 미루고, 이번 절에서는 통상적인 산술의 익숙한 예들을 사용하기로 한다.

앞에서 설명했듯 지식기는 문장들로 구성되고, 이 문장들은 표현 언어의 구문(syntax)을 따른다. 표현 언어의 구문은 적격(well-formed)인 문장을  규정한다. ex) 통상적인 산술에서는 구문의 개념이 아주 명확하다. "x + y = 4"는 적격의 문장이지만 "x4y + =" 는 그렇지 않다.

논리는 문장의 의미론, 즉 문장의 뜻도 정의해야 한다.

의미론(semantics) : 각각의 가능한 세계(possible world)에 대한 문장의 진리(truth; 참 또는 거짓 여부)를 정의한다.

표준 논리에서 모든 문장은 각각 가능한 세계에서 참 아니면 거짓이어야 한다. (참·거짓 둘 다 아닌 무언가는 존재하지 않으며, 14장의 퍼지 논리에서는 참과 거짓 사이의 진릿값들이 허용된다.)

좀 더 엄밀한 정의가 필요한 경우에는 '가능한 세계' 대신 모형(model)이라는 용어를 사용한다.




논리적 함축 관계
함축(entailment) : 한 문장이 다른 문장을 "논리적으로 따른다(follow)"는 개념을 나타내는 용어이다.

논리적 추리(logical inference) : 함축의 정의를 이용해서 결론을 이끌어내는 방법.

모형 점검(model checking) : 모든 가능한 모형을 훑으면서 KB가 참인 모든 모형에서 α가 참인지, 즉 M(KB)⊆M(a) 인지 점검하는 추리 알고리즘.

건전한(sound) 또는 진리를 보존하는(truth-preserving) 알고리즘 : 함축된 문장들만 유도하는 추리 알고리즘

바람직한 속성 : 

1. 건전성
1. 완결성(completeness)
1. 근거함(grounding)

지금까지 전제들이 참인 세계에 대해서는 결론이 반드시 참인 추론 공정을 설명했다. 좀 더 구체적으로, **만일 실제 세계에서 KB가 참이면, 건전한 추리 절차를 이용해서 KB로부터 유도한 임의의 문장 α도 실제 세계에서 참이다.** 따라서, 비록 추리 공정이 '구문', 즉 레지스터 안의 비트들이나 뇌의 전기적 점멸 패턴 같은 내부적인 물리적 구성들에 대해 작용한다고 해도, 그러한 공정은 실세계의 관계들(실세계의 일부 측면이 실세계의 다른 어떤 실상(the case)인 측면들에 의해 실상이 되는)에 대응된다.

도해 7.6
<br>
- 문장들 : 에이전트의 물리적 구성들
- 추론 : 기존의 물리적 구성들로부터 새로운 물리적 구성을 구축하는 공정.
- 논리적 추론 : 새 구성이 나타내는 세계의 측면들이 기존 구성들이 나타내는 측면들을 따른다는 점을 보장해야 한다.


# 명제 논리: 아주 간단한 논리

7.4에서는 좀 더 구체적인 명제 논리의 원리들을 설명한다. 명제 논리는 1차 논리보다는 표현력이 떨어지지만, 그래도 논리의 기본 개념들을 모두 표현할 수 있다. 

명제 논리(propositional logic) : 간단하지만 강력한 논리. 명제 논리의 구문과 그 의미론(문장의 진리를 결정하는 방식)을 설명하고, 그런 다음 어떤 문장이 다른 어떤 문장에 따른다는 함축 관계를 살펴본다. 그리고 그러한 관계를 이용해서 논리적 추리를 수행하는 간단한 알고리즘을 소개한다. 

## 구문

원자적 문장(atomic sentence)


명제 기호(proposition symbol)

복합 문장(complex sentence)


리터럴(literal) : 원자적 문장 or 원자적 문장의 부정

흔히 쓰이는 접속사(연산자) 다섯 가지 : 

1. 부정(negation) : 
1. 논리곱(conjunction) 문장 or 연언문 : 
1. 논리합(disjunction) 문장 or 선언문 : 
1. 함의(implication) or 조건부 문장 : 
1. 상호조건(biconditional) : 





## 의미론

의미론 : 특정 모형에 대한 문장의 진리를 결정하는 규칙들을 정의한다.

명제 논리에서 모형은 모든 명제 기호의 진릿값(truth value), 즉 참or거짓을 고정하는 역할만 한다.

진리표(truth table)




## 간단한 지식 기지

간단하게 불변이(immutable) 측면들에 집중하고, 가변이(mutable) 측면들은 뒤로 미루기로 한다.



## 간단한 추리 절차명제 노리적 함축은 여NP-완전(co-NP-complete)이다(즉, 아마 NP-완전보다 쉽지는 않을 것이다.) 따라서, 명제 논리에 대한 모든 알려진 추론 알고리즘의 최악의 경우의 복잡도는 입력의 크기에 대해 지수적이다.






# 명제 정리 증명

7.5와 7.6에서는 관련 추리 기술들이 잘 개발되어 있다는 장점을 서술한다.

함축 관계를 확인하는 방법 :

1. 모형 점검 : 모형들을 열거하면서 문장이 모든 모형에서 성립하는지 점검하는 방식.
1. 정리 증명(theorem proving) : 이 접근방식에서는 지식 기지에 있는 문장들에 추리 규칙들을 직접, 적용해서 주어진 문장의 증명을 구속함으로써 함축 관계를 확인한다. 모형이 많고 증명은 짧은 경우에는 이러한 정리 증명이 모형 점검보다 효율적이다.

정리 증명 알고리즘의 세부사항으로 들어가기 전에, 함축과 관련된 몇 가지 추가적인 개념 : 

1. 논리적 동치(logical equivalence) 관계 : 
1. 유효성(validity) : 
1. 만족 가능성(satisfiability)



# 추리와 증명

증명(proof)을 이끌어 내는 데 사용할 수 있는 추리 규칙(inference rule).

증명(proof) : 어떤 원하는 목표로 이어지는 결론들의 사슬.

추리 규칙 : 

1. 전건 긍정(Modus Poness) : 가장 잘 알려진 추리 규칙.
1. 논리곱 소거(AND-elimination) : 논리곱 문장에서 임의의 논리곱 성분(dusdjswl)을 추리할 수 있음을 뜻한다.

단조성(monotonicity) : 지식 기지에 정보가 추가됨에 따라 함축된 문장들의 집합이 항상 커지기만 함을 뜻한다. 임의의 문장 α와 β에 대해.



## 분해 증명

분해(resolution) : 추리 규칙. 임의의 완결적 검색 알고리즘과 결합하면 완결적인 추리 알고리즘이 나온다.

논리곱 표준형(conjunctive normal form, CNF) : 

분해 알고리즘

분해의 완결성

기초 분해 정리(ground resolution theorem)

## 혼 절과 한정절

한정절(definite clause) : 긍정 리터럴이 정확히 하나인 논리합.

혼 절(Horn classes) : 긍정 리터럴이 최대 하나인 논리합.

한정절만 담은 지식 기지가 흥미로운 이유 3가지 : 

1. 모든 한정절은 전제가 긍정 리터럴들의 논리곱이고 결론이 하나의 긍정 리터럴인 함의 문장으로 변화할 수 있다.
1. 혼 절들에 대해 추리를 수행할 때에는 다음 절에서 설명할 전방 연쇄(forward-chaining)와 후방 연쇄(backward-chaining) 알고리즘을 사용할 수 있다.
1. 의외의 유쾌한 속성 하나는, 혼 절들에 대한 ㅎ함축 관계 판정에 걸리는 시간이 지식 기반의 크기에 선형적이라는 점이다.



## 전방 연쇄와 후방 연쇄



자료 주도적(data-drive) 추론






# 효과적인 명제 모형 점검

7.5와 7.6에서는 관련 추리 기술들이 잘 개발되어 있다는 장점을 서술한다.

## 완결적인 역추적 알고리즘

데이비스-푸트넘 알고리즘(Davis-Putnam algorithm)



## 국소 검색 알고리즘




## 무작위 SAT 문제들의 지형






# 명제 논리에 기초한 에이전트

지식 기반 에이전트 개념과 명제 논리 기술을 결합해서 웜푸스 세계를 위한 간단한 에이전트를 몇 개 만들어 본다.

## 세계의 현재 상태

기준계 문제(frame problem)
해법 : 모든 명제가 동일하게 유지됨을 명시적으로 단언하는 기준계 공리(frame axiom)들을 추가하는 것. 이를 테면 각 시간 단계 t에 대해 다음과 같은 단언들을 추가하면 될 것이다.

표현적 기준계 문제(representational frame problem)

추리적 기준계 문제(inferential frame problem)

후행 상태 공리(successors-state axiom)

## 혼성 에이전트

혼성 에이전트(hybrid agent)

## 논리적 상태 추정



## 면제 추리를 이용한 계획 수립








# 요약

지식 기반 에이전트 소개, 그런 에이전트가 세계의 상태를 추론하는 데 사용하는 논리를 정의하는 방법을 제시했다. 이번 장의 요점은 다음과 같다.

지능적 에이전트가 좋은 결정을 내리려면 세계에 관한 지식이 필요하다.

에이전트 안에서 지식은 지식 표현 언어로 작성된 문장들의 형태로 존재한다. 그러한 문장들은 에이전트 안의 지식 기반에 저장된다.

지식 기반 에이전트는 지식 기지와 추리 메커니즘으로 구성된다. 지식 기반 에이전트는 세계에 관한 문장들을 지식 기지에 저장하고, 추리 메커니즘을 이용해서 새로운 문장을 추리하고, 그 문장들을 이용해서 다음 동작을 결정하는 식으로 작동한다.

지식 표현 언어는 문장의 구조를 명시하는 문법과 각각의 가능한 세계 또는 모형 안에서의 각 문장의 진릿값을 결정한는 의미론으로 정의된다.

추론을 이해하려면 문장들 사이의 함축 관계가 아주 중요하다. 만일 문장 α가 참인 모든 세계에서 문장 β가 참이면, α는 β를 함축한다. 동치 정의에는 문장 a⇒β의 유효성과 문장 a∨￢β의 만족 불가능성이 포함된다.

추리는 기존의 문장들에서 새 문장을 이끌어 내는 과정이다. 건전한 추리 알고리즘은 오직 기존 문장들이 함축하는 문장들만 유도한다. 완결적인 추리 알고리즘은 기존 문장들의 함축하는 모든 문장을 유도한다.

명제 논리는 명제 기호들과 논리 접속사들로 이루어진 간단한 언어이다. 명제 논리는 참임이 알려진 명제들과 거짓임이 알려진 명제들, 그리고 전혀 알려지지 않은 명제들을 처리할 수 있다.

주어진 고정된 명제 어휘하에서 가능한 모형들의 집합은 유한하다. 따라서 모형들을 모두 열거해서 함축 관계를 점검할 수 있다. 명제 논리를 위한 효율적인 모형 점검 추리 알고리즘에는 역추적 방법과 국소 검색 방법들이 포함되는데, 이들을 이용해서 커다란 문제를 빠르게 풀 수 있는 경우가 많다.

추리 규칙은 증명을 찾는 데 사용할 수 있는 건전한 추리 패턴이다. 분해 규칙을 이용하면 논리곱 표준형으로 표현된 지식 기지를 위한 완결적인 추리 알고리즘을 만들 수 있다. 전방 연쇄와 후방 연쇄는 혼 형태의 지식 기지를 위한 아주 자연스러운 추론 알고리즘들이다.

WALKSAT 같은 국소 검색 방법들을 해답을 찾는 데 사용할 수 있다. 그런 알고리즘들은 건전하지만 완결적이지는 않다.

논리적 상태 추정을 위해서는 지금까지의 관찰들에 일관적인 가능한 상태들의 집합을 서술하는 논리적 문장을 유지해야 한다. 각각의 갱신 단계에는 환경의 전이 모형을 이용한 추리가 요구되는데, 그러한 전이 모형은 각 유량의 변화 방식을 명시하는 후행 상태 공리들로부터 구축된다.

논리적 에이전트는 SAT 해결을 통해서, 즉 목표에 도달하는 미래의 동작열을 명시하는 가능한 모형들을 찾아냄으로써 의사결정을 수행할 수 있다. 이 접근방식은 완전 관찰 가능 환경이나 무감지기 환경에서만 작동한다.

명제 논리는 크기가 무제한인 환경으로 확장되지 않는다. 이는 시간, 공간, 그리고 객체들 사이의 관계에 대한 보편적 패턴을 간결하게 표현하기에는 명제 논리의 표현력이 부족하기 때문이다.













