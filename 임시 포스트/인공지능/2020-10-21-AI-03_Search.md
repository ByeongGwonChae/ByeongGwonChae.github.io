---
title: "인공지능-03. 탐색"
category:
  - AI
tag:
  - AI
toc: true
toc_sticky: true
---

에이전트가 결정론적이고 관찰 가능하며 정적이로 완전히 알려진 환경 안에서 동작을 선택할 때 사용할 만한 방법들.

이러한 환경에서 에이전트는 자신의 목표를 달성할 수 있는 일련의 동작들을 구축한다. 그러한 공정을 가리켜 탐색이라고 부른다.

이번 장 목표 : 

- 문제(problem)와 해답(solution)을 엄밀하게 정의하는 방법
- 그 정의들을 이해하는데 도움이 되는 예제 몇 가지
- 그러한 문제들을 푸는데 사용할 수 있는 탐색 알고리즘들

정보 없는(uninformed) 탐색 알고리즘 : 

- 문제의 정의 이외에는 정보가 주어지지 않는 알고리즘
- 풀 수 있는 문제라면 그 어떤 문제도 풀 수 있는 알고리즘도 존재한다.
- 그러나 문제를 효율적으로 풀 수 있는 것은 하나도 없다.

정보 있는(informed) 탐색 알고리즘 : 

- 해답이 있을 만한 곳에 대한 힌트가 주어지면 상당히 효율적으로 문제를 풀 수 있다.


문제의 **해답**은 항상 **동작들의 고정된 순차열**(fixed sequence; 고정 동작열)인 아주 간단한 형태의 과제 환경으로만 국한된다.

4장에서는 에이전트의 미래 동작들이 미래의 지각에 따라 바뀔 수도 있는 과제 환경으로만 국한된다.


# 문제 해결 에이전트

문제 해결 에이전트(problem-solving agent) : 목표 기반 에이전트의 하나.

목표(goal) : 목표가 만족되었을 때의 세계의 상태들로 이루어진 집합목표가 있으면 에이전트가 달성하고자 하는 목적들이 제한되며, 따라서 고려해야 할 동작들도 제한된다. 결과적으로 행동을 조직화하기가 쉬워진다.

목표 형식화(goal formulation) : 문제 해결의 첫 단계. 현재 상황과 에이전트의 성과 측정에 기초해서 목표를 형식화한다.

문제 형식화(problem formulation) : 목표를 달성하기 위해 고려할 동작들과 상태들을 결정하는 공정

그 값이 알려지지 않은 직접적 옵션들이 여러 개 주어졌을 때, 에이전트는 궁극적으로 값이 알려진 상태들로 이어지는 **향후 동작들을 먼저 조사**함으로써 **다음 동작을 결정**할 수 있다. (여기서 옵션이란 키보드←↑→↓ 등의 액션(action)을 뜻한다.)

"향후 동작들을 조사한다"를 좀 더 구체적으로 이해하려면 환경의 속성들을 좀 더 구체적이어야 한다.

- 관찰 가능
- 이산적
- 기지
- 결정론적

## 잘 정의된 문제와 해답

문제(problem)의 5가지 요소

1. 초기 상태(initial state) - 에이전트가 처음 시작하는 상태.
1. 동작(action) - 특정 상태 s에서 에이전트가 할 수 있는 동작들.
1. 전이 모형(transition model) - 상태 s에서 동작 a를 수행해서 나온 상태. (각 동작의 결과)
1. 목표 판정(goal test) 함수 - 주어진 상태가 목표 상태인지 판정한다. (탐색의 끝인지 확인하는 것과 관련있다.)
1. 경로 비용(path cost) 함수 - 각 경로에 수치 비용을 배정한다.
- 단계 비용(step cost) - 상태 s에서 상태 s`로 가는 동작 a를 실행하는 비용

상태 공간(state space) : 초기 상태, 동작들, 전이 모형의 조합. 초기 상태에서 시작해서 임의의 동작열을 통해 도달할 수 있는 모든 상태의 집합.

그래프(graph) : 다음과 같은 조건의 상태 공간을 의미한다.

- 노드 → 상태
- 노드들 사이의 링크 → 동작
- 유향 네트워크(directed network)


문제의 환경 : 하나의 상태 공간

문제의 해답 : 상태 공간 안에서 초기 상태에서 목표 상태로 가는 동작열

최적해(optimal solution) : 모든 해답 중 경로 비용이 가장 낮은 것

# 문제 형식화

앞 절에서 문제를 5개의 요소로 형식화해 보았다. 이러한 형식화가 합당해 보이지만, 이는 여전히 하나의 모형, 즉 추상적인 수학적 서술이지 실질적인 어떤 것은 아니다.
{ ... }
이렇게 표현에서 세부사항을 제거하는 절차를 추상화(abstraction)라고 부른다.

추상화는 상태 서술의 추상화는 물론 동작 자체의 추상화도 필요하다.

적절한 추상화 수준을 좀 더 정밀하게 정의할 수는 없을까?

임의의 추상적 해답을 좀 더 상세한 세계의 한 해답으로 확장할 수 있다면 그 추상화은 **유효하다**(valid).

추상화된 문제의 해답에 잇는 각 동작을 원래 문제의 것보다 더 쉽게 수행할 수 있따면, 그 추상화는 **유용하다**(useful)

따라서 **좋은 추상화**에는 유효성을 유지하고 추상적 동작들을 쉽게 실행할 수 있음을 보장하는 한도 안에서 세부사항을 최대한 제거하는 것이 관여한다. 유용한 추상을 구축하는 능력이 없다면 지능적 에이전트는 현실 세계에 완전히 매몰될 것이다.


# 문제의 예

문제의 형식화하는 단계

장남감 문제(toy problem) : 다양한 문제 해결 방법의 이해 또는 연습을 목적으로 한 것. 간결하고 정확하게 서술할 수 있기 때문에 서로 다른 연구자들이 알고리즘의 성능을 비교하는데 유용하다.

- 진공청소기 세계
- 8-퍼즐(8-puzzle)
- 볼록 밀기 퍼즐(sliding-block puzzle)
- 8-퀸 문제(8-queens problem)

실세계 문제(real-world problem) : 사람들이 그 해답을 실제로 원하고 요구하는 문제들. 이런 문제들은 모두가 동의하는 한 가지 방식으로 서술하기 힘든 경우가 많은데, 아래에 나온 서술에서 적어도 해당 형식화들의 전반적인 상을 파악할 수는 있을 것이다.

- 노선 찾기 문제(route-finding problem)
- 순회 문제(touring problem)
- 순회 판매원 문제(traveling salesperson problem, TSP)
- VLSI 배치(layout) 문제
- 로봇 내비게이션(robot navigation)
- 자동 조립 시퀀싱(automatic assembly sequencing)
- 단백질 설계(protein desing)

# 해답의 탐색

문제를 푸는 단계

해답은 하나의 동작열이므로, 탐색 알고리즘은 가능한 여러 동작열들을 살펴보는 식으로 작동한다. 초기 상태에서 시작하는 가능한 동작열들은 하나의 탐색 트리(search tree)를 형성한다.

뿌리 : 초기상태
마디(node) : 문제의 상태 공간에 있는 상태
확장(expanding) : 
생성(generating) : 
부모 노드(parent node) : 
자식 노드(child node) : 
잎 노드(leaf node) : 
전선(frontier) : 주어진 한 시점에서 확장할 수 있는 모든 잎 노드의 집합

모든 탐색 알고리즘은 이 기본 구조를 따른다.

탐색 알고리즘마다 다른 점은 다음에 확장할 상태를 선택하는 방식인데, 이를 탐색 전략(search strategy)라고 부른다.




탐색된 집합(explored set) : 이 집합에는 확장된 모든 노드가 들어 있다. 새로 생성된 노드 중 이전에 생성된 노드들과 일치하는 것들, 즉 탐색된 집합이나 전선에 들어 있는 것들은 다시 전선에 추가하지 않고 폐기해도 좋다.






## 탐색 알고리즘의 기반구조

모든 노드(자료구조)의 4가지 요소

n.STATE : 
n.PARENT : 
n.ACTION : 
n.PATH-COST : 

노드와 상태를 구분하는 것은 중요하다. 노드는 탐색 트리를 나타내는 데 쓰이는 부기(bookkeeping)용 자료구조이다. 상태는 세계의 구성(configuration)에 해당한다. 따라서, 노드들은 PARENT 포인터들로 정의되는 특정 경로상에 존재하지만 상태들은 그렇지 않다. 더 나아가서, 서로 다른 두 노드가 같은 세계 상태를 담을 수 있다(그 상태가 서로 다른 두 탐색 경로를 통해 생성되었다면).

대기열(queue) : 확장할 다음 노드를 손쉽게 선택할 수 있는 자료구조

EMPTY?(queue) : 대기열에 아무 요소도 없을 때에만 참(true)을 돌려준다.
POP(queue) : 대기열의 첫 요소를 뽑아서(제거) 돌려준다.
INSERT(element, queue) : 주어진 요소(element)를 대기열에 추가하고 그 대기열을 돌려준다.

대기열에는 FIFO, LIFO, 우선순위 대기열의 방식들이 있다.

탐색된 집합은 반복된 상태들을 효율적으로 점검할 수 있는 해시 테이블로 구현하면 될 것이다.





## 문제 해결 성능 측정

탐색 알고리즘의 성능은 다음 4가지로 평가할 수 있다.

1. 완결성 : 문제에 해답이 존재할 때 알고리즘이 해답을 반드시 찾아내는가?
1. 최적성 : 탐색 전략이 최적해를 찾아내는가?
1. 시간 복잡도 : 해답을 찾는데 얼마나 시간이 걸리는가?
1. 공간 복잡도 : 탐색을 수행하는데 메모리가 얼마나 필요한가?

↓전형적인 측정 기준. 그래프가 탐색 프로그램의 입력으로 쓰이는 명시적인 자료구조일 때 적합하다.

|V| + |E| : 상태 공간 그래프의 크기
V : 그래프의 정점(vertex; 노드) 집합
E : 간선(edge; 연결선) 집합

↓그러나 인공지능에서 그래프는 초기 상태와 동작들, 전이 모형을 통해서 암묵적으로 표현되는 경우가 많으며, 그래프가 무한인 경우도 흔하다. 이런 이유로 다음과 같이 복잡도가 표현된다.

복잡도를 표현하는 3가지 수량 : 

1. b : 임의의 노드의 후행자 최대 개수(분기 계수(branching factor))
1. d : 가장 얕은 목표 노드의 깊이(depth).
1. m : 상태 공간의 임의의 경로의 최대 길이

대부분의 경우에서 이책은 트리의 탐색에 대한 시간, 공간 복잡도를 이야기한다. 그래프에 관해서는 상태 공간의 경로들이 얼마나 '과잉'인지에 따라 답이 다르다.

- 탐색 비용(search cost) : 일반적으로 시간 복잡도에만 의존하나, 메모리 사용량을 탐색 비용에 포함시킬 수도 있다.
- 총 비용(total cost) : 탐색 비용 + 발견된 해답의 경로 비용





# 정보 없는 탐색 전략

정보 없는 탐색(uniformed search) 또는 맹목적 탐색(blind search)

이 부류의 전략들은 상태에 관해 문제 정의에 주어진 것 이상의 정보를 제공받지 못하는 상황을 위한 것이다. 그런 상황에서 할 수 있는 일은 후행자들을 생성하고 목표 상태와 비목표 상태를 구분하는 것뿐이다.

일반화하자면, 탐색 트리의 임의의 깊이에서 그 깊이에 있는 모든 노드가 확장된 후에야 그 다음 수준의 노드들이 확장된다.

정보 없는 탐색 방법 : 문제의 정의에만 접근할 수 있다.

- 너비 우선 탐색 : 가장 얕은 노드를 먼저 확장한다. 이 알고리즘은 완결적이고, 단계 비용이 일정할 때 최적이지만, 공간 복잡도가 지수적이다.
- 균일 비용 탐색 : 경로 비용이 가장 낮은 노드를 확장한다. 이 알고리즘은 일반적인 단계 비용들에 대해 최적이다.
- 깊이 우선 탐색 : 아직 확장되지 않은 가장 깊은 노드를 먼저 확장한다. 이 알고리즘은 완결적이지도 않고 최적도 아니지만, 공간 복잡도가 선형이다. 깊이 제한 탐색은 여기에 깊이 한계를 추가한다.
- 반복 심화 탐색 : 목표가 나올 때까지 깊이 한계를 증가하면서 깊이 우선 탐색을 호출한다. 이 알고리즘은 완결적이고, 단계 비용이 일정할 때 최적이며, 시간 복잡도는 너비 우선 탐색과 비슷하다. 그리고 공간 복잡도는 선형이다.
- 양방향 탐색 : 시간 복잡도를 크게 줄일 수 있지만 항상 적용할 수 있는 것은 아니며, 공간이 너무 많이 필요할 수 있다.


<div id="allalgorithm">
	<!-- Nav tabs -->
	<ul class="nav nav-pills">
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#best_first_graph_search">최선 우선 그래프 탐색(Best First Graph Search)</a>
		</li>
		<li class="nav-item">
			<a class="nav-link" data-toggle="tab" href="#recursive_best_first_search">반복 최선 우선 탐색(Recursive Best First Search)</a>
		</li>
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">정보 없는 탐색</a>
      <div class="dropdown-menu">
        <a class="dropdown-item" href="#breadth_first_graph_search">너비 우선 그래프 탐색(Breadth First Graph Search)</a>
        <a class="dropdown-item" href="#depth_first_graph_search">깊이 우선 그래프 탐색(Depth First Graph Search)</a>
        <a class="dropdown-item" href="#uniform_cost_search">균일 비용 탐색(Uniform Cost Search)</a>
        <a class="dropdown-item" href="#depth_limited_search">깊이 제한 탐색(Depth Limited Search)</a>
        <a class="dropdown-item" href="#iterative_deepening_search">반복 심화 깊이 우선 탐색(Iterative Deepening Search)</a>
        <a class="dropdown-item" href="#bidirectional_search">양방향(적용 가능한 경우) 탐색(bidirectional search)</a>
      </div>
    </li>
    <li class="nav-item dropdown">
      <a class="nav-link dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">정보 있는 탐색</a>
      <div class="dropdown-menu">
			  <a class="nav-link" data-toggle="tab" href="#greedy_best_first_search">Greedy Best First Search</a>
        <a class="nav-link" data-toggle="tab" href="#astar_search">A*-Search</a>
        <a class="dropdown-item" href="#">균일</a>
        <a class="dropdown-item" href="#">깊이</a>
        <a class="dropdown-item" href="#">반복</a>
        <a class="dropdown-item" href="#">양방</a>
      </div>
    </li>
	</ul>
	<!-- Tab panes -->
	<div class="tab-content">
		<div class="tab-pane container active" id="breadth_first_graph_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="depth_first_graph_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="uniform_cost_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="depth_limited_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="iterative_deepening_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="bidirectional_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="greedy_best_first_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="astar_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="best_first_graph_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
		<div class="tab-pane container fade" id="recursive_best_first_search">
<div markdown="1">

```js
테스트중
```

</div>
		</div>
	</div>
</div>








## 너비 우선 탐색(breadth-first search) 

뿌리 노드를 먼저 확장하고, 뿌리 노드의 모든 후행자를 확장하고, 그 후행자들의 후행자들을 확장하는 식으로 진행하는 간단한 전략. 일반화하자면, 탐색 트리의 임의의 깊이에서 그 깊이에 있는 모든 노드가 확장된 후에야 그 다음 수준의 노드들이 확장된다.

확장되지 않은 노드 중 가장 얕은 노드를 선택해서 확장한다는 전략을 사용한다. 이러한 전략은 전선을 FIFO 대기열에 담기만 하면 간단히 구현할 수 있다.

즉, 새 노드들(부모보다 항상 더 깊은 수준에 있는)이 대기열의 뒤에 추가되고, 오래된 노드들(새 노드들보다 항상 더 얕은)이 먼저 확장된다. 이 알고리즘에는 일반적 그래프 탐색 알고리즘을 약간 비튼 부분이 있는데, 바로 목표 판정을 확장할 노드를 선택한 시점에서 수행하는 것이 아니라 애초에 노드를 생성할 때 수행한다.

또한, 그래프 탐색을 위한 일반적 틀을 따르는 이 알고리즘이 전선이나 탐색된 집합에 이미 있는 노드로 이어지는  새 경로를 모두 폐기한다는 점도 주목하기 바란다. 그런 경로의 깊이가 이미 발견된 임의의 경로의 깊이보다 더 얕을 수는 없다는 점을 쉽게 이해할 수 있을 것이다. 따라서 너비 우선 탐색에서 전선에 잇을 각 노드로 가는 경로는 항상 가장 얕은 경로이다.



- 너비 우선 탐색에서는 실행 시간보다 메모리 요규량이 더 큰 문제이다. (다행히 메모리를 덜 사용하는 다른 전략들이 존재한다.)
- 시간은 여전히 주요 오인이라는 것이다. 일반화하자면, 지수적 복잡도를 가진 탐색 문제는 극히 간단한 경우가 아닌 한 정보 없는 방법으로는 풀 수 없다.







## 균일 비용 탐색(uniform-cost search)

f(n) = g(n)

BFS을 조금 증강한다면, 임의의 단계 비용 함수에 대해 최적인 알고리즘을 찾아낼 수 있다. 그러한 알고리즘인 UCS은 가장 얕은 노드를 탐색하는 것이 아니라 경로 비용 g(n)이 가장 낮은 노드 n을 확장한다. 이를 위해 알고리즘은 전선을 g를 기준으로 정렬되는 우선순위 대기열에 저장한다.

이 알고리즘에는 대기열을 경로 비용에 따라 정렬하는 것 외에도 너비 우선 탐색과 다른 점이 두 개 더 있다. 

1. 이 알고리즘은 목표 판정을 노드가 처음 생성될 때 적용하는 것이 아니라 **확장을 위해 선택될 때** 적용한다. 이유는, 생성된 첫 목표 노드가 덜 최적인 경로에 있을 수도 있기 때문이다. (이 찌발 더럽게 복잡하네)
1. 현재 전선에 있는 한 노드로의 더 나은 경로가 발견되는 경우를 위한 또 다른 판정이 추가되었다는 것이다.

균일 비용 탐색은 노드들을 해당 최적 경로 비용의 순서로 확장한다. 다라서 확장을 위해 선택된 첫 목표 노드는 반드시 최적해이어야 한다.

따라서, UCS은 깊이 d의 노드들을 불필요하게 확장함으로써 BFS보다 실제로 더 많은 작업을 수행하게 된다.

## 깊이 우선 탐색(depth-first search)

항상 탐색 트리의 현재 전선에서 가장 깊은 노드를 확장한다. 탐색은 탐색 트리의 가장 깊은 수준, 즉 노드들에 후행자가 전혀 없는 수준으로 직접 나아간다. 그 노드들을 확장하면 그 노드들은 전선에서 떨어져 나간다. 그러면 탐색은 아직 탐색하지 않은 후행자들을 가진, 다음으로 깊은 노드들로 '후퇴'(back up) 한다. (->이건 구현되지 않는다. 그냥 openedlist에서 그 다음 노드를 실행한다. ㅅㅂ python코드에도 없는 거라서 뭔 소리인가 ㅈㄴ 고민했다.)

BFS은 FIFO대기열을 사용하지만 DFS은 LIFO 대기열을 사용한다. LIFO 대기열을 사용한다는 것은 가장 최근 생성된 노드가 확장을 위해 선택된다는 뜻이다. 그 노드는 아직 확장되지 않은 노드 중 가장 깊은 노드임이 분명하다. 왜냐하면 그 노드는 그 부모보다 한 수준 더 깊은 노드인데, 그 부모는 선택 당시 아직 확장되지 않은 가장 깊은 노드였기 때문이다.

DFS은 graph-search스타일의 구현 대신 자식 노드들 각각에 대해 차례로 함수 자신을 호출하는 재귀 함수를 사용해서 구현하는 것이 일반적이다. (깊이에 한계를 둔 재귀적 깊이 우선 알고리즘은 DLS에서 다룬다.)

...

지금까지의 논의를 보면 깊이 우선 탐색이 너비 우선 탐색보다 확실히 나은 점이 없어 보인다. 그러나 공간 복잡도에서는 장점을 가진다. 그래프 탐색에서는 장점이 없지만, 깊이 우선 트리 탐색은 루트에서 잎 노드로의 경로 하나와 그 경로의 각 노드에 대한 아직 확장되지 않은 동기(sibling) 노드들만 저장하면 된다. 한 노드를 확장하고 그 모든 후손을 완전히 탐색했다면 해당 노드는 메모리에서 제거해도 된다. 분기 계수가 b이고 최대 깊이가 m인 상태 공간에서 깊이 우선 트리 탐색은 단 O(bm)개의 노드만 저장하면 된다.

이러한 장점 때문에 깊이 우선 트리 탐색은 제약 만족(6장), 명제 만족(7장), 논리 프로그래밍(9장) 같은 인공지능의 여러 분야에서 기본적인 동력으로 쓰이고 있다.

이보다도 메모리를 덜 쓰는 깊이 우선 탐색의 한 변형으로 역추적 탐색(backtracking search; 되추적 탐색, 퇴각탐색)이 있다. 역추적 탐색에서는 모든 후행자를 한꺼번에 생성하는 대신 한 번에 하나씩만 생성한다. 각각의 부분적으로 확장된 노드는 다음에 생성할 후행자를 기억한다. 이렇게 하면 메모리 요구량이 O(bm)이 아니라 O(m)이 된다. 역추적 탐색은 또 다른 메모리 절약(그리고 시간 절약)요령을 사용한다. 바로, 현재 상태 서술을 복사하는 대신 직접 수정해서 후행자를 생성한다는 것이다. 이렇게 하면 메모리 요구량이 상태 서술 하나와 O(m)개의 동작들로 줄어든다. 이런 요령이 가능하려면 다음 후행자를 생성하기 위해 부모 노드로 돌아갈 때 각 수정을 취소(undo)할 수 있어야 한다. 상태 서술의 덩치가 큰 문제에서는 이런 기법이 성공에 핵심적이다.

## 깊이 제한 탐색(depth-limited search)

무한한 상태 공간에서 깊이 우선 탐색이 무참히 실패하는 문제점은 미리 정해진 깊이 한계 l로 탐색을 제한함으로써 완화할 수 있다. 즉, 깊이 L의 노드들은 마치 후행자가 하나도 없는 것처럼 취급하면 된다. 이런 접근방식을 DLS이라고 부른다. 깊이 제한은 무한 경로 문제를 해결한다. 그러나 안타깝게도 만일 l < d 로 선택하면, 즉 가장 얕은 목표가 깊이 한계 너머에 있다면 알고리즘은 완결되지 않는다. (d를 미리 알지 못하는 경우 그런 선택이 일어날 수 있다.) 또한 만일 l > d이면 DLS은 최적이 아니다. 시간 복잡도는 O(b^l^)이고 공간 복잡도는 O(bl)이다. 깊이 우선 탐색은 l=∞인 DLS의 특수 경우로 볼 수 있다.

탐색 한계를 문제에 대한 지식에 기초해서 선택할 수 있는 경우도 있다. .... 그러나 대부분의 문제에서는 문제를 풀기 전까지는 쓸 만한 깊이 한계를 알지 못한다.

DLS은 일반적 트리 탐색 또는 그래프 탐색 알고리즘을 간단히 수정해서 구현할 수 있다. 간단한 재귀 알고리즘으로 구현할 수도 있다. 깊이 제한 탐색에서는 실패가 두 종류로 나뉨에 주목하기 바란다. 표준적인 failure 값은 해답이 없음을 뜻하고, cutoff 값은 주어진 깊이 한계 안에서 해답이 없음을 뜻한다.










## 반복 심화 깊이 우선 탐색(iterative deepening search)

반복 심화 탐색(iterative deepening search) 또는 반복 심화 깊이 우선 탐색

이 탐색은 최상의 깊이 한계를 찾아내는 일반적 전략으로, 흔히 깊이 우선 트리 탐색과 결합해서 쓰인다. 이 전략은 목표를 발견할 때까지 깊이 한계를 점점 증가시켜 나간다(처음에는 0, 그 다음에 1, 그다음에 2, 등등으로). 깊이 한계가 가장 얕은 목표 노드의 깊이인 d에 도달하면 그 깊이에서 목표를 발견하게 된다.

IDS은 DFS의 장점과 BFS의 장점을 모두 가지고 있다. 깊이 우선 탐색처럼 이 알고리즘은 메모리 요구량이 적당하다. 정확히 말하면 O(bd)이다. 그리고 너비 우선 검색처럼 분기 계수가 유한할 때 완결적이고 경로 비용이 노드 깊이의 비감소 함수일 때 최적이다. 

IDS에서는 상태들이 여러 번 생성되므로 낭비가 심할 것처럼 보인다. 그러나 그리 심하지는 않다. 이유는, 모든 수준의 분기 계수가 같은(또는 거의 같은) 검색 트리에서는 대부분의 노드가 최하위 수준에 있으므로, 그 위 수준들에서 노드가 여러 번 생성된다고 해서 큰 문제는 되지는 않기 때문이다. IDS에서 최하위 수준(깊이 d)의 노드들은 한 번만 생성되고, 그 위 수준은 두 번 생성된다. 그런 식으로 올라가다 최상위 수준인 뿌리의 자식 노드들은 d번 생성된다. 따라서 최악의 경우에 생성된 총 노드 개수는 다음과 같다.

( 적기 귀찮아서 안적음. p.108 )

이로부터 시간 복잡도를 구하면 O(b^d^)인데, 이는 너비 우선 검색의 것과 점근적으로 같다. 상위 수준들에서의 노드 중복 생성에 따른 추가 비용이 있지만 그리 크지 않다. 

반복적인 중복 생성이 정말로 걱정된다면, 가용 메모리를 거의 다 소비할 때까지 BFS을 수행하고, 그 다음에는 모든 노드에서 시작해서 IDS을 실행하는 혼성 방법을 사용할 수도 잇다. 일반적으로, 검색 공간이 크고 해답의 깊이가 알려지지 않을 때의 정보 없는 검색 방법으로는 반복 심화가 선호된다.

반복 심화 검색은 반복마다 새 노드들의 계층 전체를 먼저 탐색한 후 다음 계층으로 나아간다는 점에서 너비 우선 검색과 비슷하다. UCS 에 대응되는, 즉 UCS처럼 최적성을 보장하되 과도한 메모리 요구량은 피할 수 있는 반복적 방법도 개발할 가치가 있을 것이다. 그렇게 해서 나온 알고리즘을 반복적 연장 검색(iterartive lengthening search)라고 부르는데, 안타깝게도 반복 연장 방법은 균일 비용 검색보다 추가 비용이 상당히 큰 것으로 밝혀졌다.








## 반복적 연장 탐색(lengthening search)




## 양방향 탐색(bidirectional search)

양방향 검색에 깔린 착안은 두 가지 검색, 즉 초기 상태에서 시작하는 전방(순방향) 검색과 목표에서 시작하는 후방(역방향) 검색을 동시에 진행한다는 것이다. 두 검색이 중간에서 만난다면 성공이다. 이러한 착안은 b^d/2^+b^d/2^이 b^d^보다 훨씬 작다는 데에서 비롯된 것이다. 기하학적으로 말하자면, 출발점과 목표를 각각 원점으로 하는 두 작은 원의 넓이가 출발점을 원점으로 해서 목표에 닿는 커다란 원의 넓이보다 훨씬 작다.

양방향 검색을 구현할 때에는 목표 판정을 두 검색의 전선들이 교차하는지를 점검하도록 변경한다. 만일 두 전선이 만난다면 해답이 발견된 것이다. (그러한 첫 번째 해답이 최적이 아닐 수 있다. 심지어 두 검색 모두 너비 우선일 때에도 그렇다. 따라서 추가적인 검색을 통해서 틈을 가로지르는 다른 지름길이 있는지 확인해 볼 필요가 있다.) 각 노드를 생성 또는 확장을 위해 선택할 때 해시 테이블을 이용한다면, 그러한 교차 판정에는 상수 시간이 걸린다. 예를 들어 문제의 해답이 깊이 d = 6에 있으며 각 방향으로 한 번에 한 노드씩 BFS을 진행한다면, 최악의 경우 두 검색은 깊이 3에서 모든 노드를 생성했을 때 만나게 된다. b=10이라고 하면 총 2,220개의 노드가 생성된다(표준적인 너비 우선 검색에서는 1,111,110개). 따라서 두 방향 모두 너비 우선 검색을 사용하는 양방향 검색의 시간 복잡도는 O(b^d/2^)이다. 공간 복잡도 역시 O(b^d/2^)이다. 만일 두 검색 중 하나에 반복 심화를 적용한다면 이를 대략 절반으로 줄일 수 있으나, 교차 판정을 위해서는 두 전선 중 적어도 하나는 메모리에 유지해야 한다. 이 공간 요구량은 양방향 검색의 가장 현저한 약점이다.

양방향 검색은 시간 복잡도가 작다는 점에서 매력적이긴 하지만, 역방향으로 검색하는 방법을 알아내지 못하면 무용지물이다. 후방 검색은 생각만큼 간단하지 않다. 상태 x가 후행자들 중 하나인 상태를 x의 선행자(predecessor)라고 부르기로 하자. 양방향 검색에는 그러한 선행자들을 계산하는 방법이 필요하다. 상태 공간의 모든 동작이 가역적이라면, x의 선행자들을 계싼하는 방법이 필요하다. 상태 공간의 모든 동작이 가역적이라면, x의 선행자들과 후행자들은 같다. 그렇지 않은 경우에는 상당한 창의력이 필요하다.

"목표에서 시작해서 역방향으로 검색한다"에서 '목표'가 무엇을 뜻하는지 생각해보자. 8-퍼즐 문제와 루마니아 여행 경로 찾기 문제에서는 목표 상태가 하나뿐이므로 후방 검색은 전방 검색과 아주 비슷하다. 여러 개의 목표 상태들이 명시적으로 주어진다면, 그 목표 상태들이 직접적인 선행자들인 가짜 목표 상태를 하나 만들면 된다. 그러나 n-퀸 문제의 "그 어떤 퀸도 다른 퀸을 공격하지 않는다"라는 목표처럼 목표가 추상적인 서술이면 양방향 검색을 사용하기 힘들다.


## 정보 없는 탐색 전략들의 비교

트리 탐색 버전들의 4가지 평가 비교

||너비 우선|균일 비용|깊이 우선|깊이 제한|반복 심화|양방향(적용 가능한 경우)|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|완결성|예<sup>a</sup>|예<sup>a,b</sup>|아니요|아니요|예<sup>a</sup>|예<sup>a,d</sup>|
|시간|O(b<sup>d</sup>)|O(b<sup>1 + ⌊C*/ε⌋</sup>)|O(b<sup>m</sup>)|O(b<sup>l</sup>)|O(b<sup>d</sup>)|O(b<sup>d/2</sup>)|
|공간|O(b<sup>d</sup>)|O(b<sup>1 + ⌊C*/ε⌋</sup>)|O(bm)|O(bl)|O(bd)|O(b<sup>d/2</sup>)|
|최적성|예<sup>c</sup>|예|아니오|아니요|예<sup>c</sup>|예<sup>c,d</sup>|

↑트리 탐색 전략들의 평가. 

- b는 분기 계수
- d는 가장 얕은 해답의 깊이
- m은 탐색 트리의 최대 깊이
- l은 깊이 한계 

완결성에서 '예'에 붙은 첨자의 의미는 다음과 같다.

- a : 만일 b가 유한하면,
- b : 양수 e에 대해 만일 단계 비용이 ≥ε이면,
- c : 만일 단계 비용들이 모두 동일하면,
- d : 두 방향 모두 너비 우선 탐색이면,



그래프 탐색의 경우 주된 차이 :

1. 깊이 우선 탐색이 유한한 상태 공간에서 완결적이라는 점
1. 시간·공간 복잡도가 상태 공간의 크기에 의해 유계라는 점


# 정보 있는(발견법적) 탐색 전략들

정보 있는 탐색(informed search) 또는 발견법적 탐색(heuristic search)

정보 있는 탐색 방법 : n에서 해답으로의 비용을 추정하는 발견법적 함수에 접근할 수 있다.

- 일반적인 최선 우선 탐색 알고리즘 : 평가 함수에 기초해서 노드를 선택한다.
- 탐욕적 최선 우선 탐색 : h(n)이 최소인 노드들을 확장한다. 이 알고리즘은 최적은 아니나, 효율적인 경우가 많다.
- A* 탐색 : f(n) = g(n) + h(n)이 최소인 노드들을 확장한다. h(n)이 허용 가능이거나(Tree-search의 경우) 일관적일 때(Graph-search의 경우) 완결적이고 최적이다. 공간복잡도는 여전히 비실용적이다.
- RBFS(재귀적 최선 우선 탐색) 과 SMA*(단순화된 메모리 제한 탐색) : 안정적이고 최적성을 갖춘 탐색 알고리즘. 제한된 양의 메모리를 사용한다는 특징이 있다. 시간이 충분히 주어진다면 이 알고리즘들은 A*가 메모리 부족 때문에 풀지 못하는 문제들을 풀 수 있다.

--------------------------------------

정보 있는 검색(informed search) 전략, 즉 문제 자체의 정의는 물론 문제에 관련된 지식도 활용하는 검색 전략이 정보 없는 전략보다 더 효율적으로 해답을 찾을 수 잇는 이유와 과정을 살펴본다.

이번 절에서 고려할 일반적 접근방식은 최선 우선 탐색(best-first search)이다. 최선 우선 검색은 일반적인 TREE-SEARCH나 GRAPH-SEARCH 알고리즘의 한 사례로, 확장할 노드를 평가 함수(evaluation function) f(n)에 기초해서 선택한다는 것이 특징이다.  평가 함수는 비용 추정치로 간주되므로, 평가가 가장 낮은 노드가 제일 먼저 확장된다. 최선 우선 그래프 검색의 구현은 UCS의 것과 같되 우선순위 대기열을 정렬할 때 g 대신 f를 사용한다는 점이 다르다.

f의 선택은 검색 전략을 결정한다. 대부분의 최선 우선 알고리즘에서 평가 함수 f에는 h(n)으로 표기하는 발견법적 함수(heuristic function)가 포함된다.

h(n) = 노드 n에 해당하는 상태에서 목표 상태로의 가장 싼 경로의 추정 비용

(h(n)은 하나의 노드를 입력받지만, g(n)과는 달리 오직 그 노드의 상태에만 의존한다.)

문제에 관한 추가 지식을 검색 알고리즘에 알려 주는 수단으로 가장 흔히 쓰이는 것은 발견법적 함수이다. 일단 지금은 이들이 문제에 고유한 임의의 음이 아닌 함수이되 한 가지 제약이 있다고만 알면 될 것이다. 한 가지 제약이란, 만일 n이 목표 노드이면 반드시 h(n)=0이어야 한다는 것이다. 이번 절의 나머지 부분은 발견법적 정보를 이용해서 검색을 바람직한 방향으로 이끄는 2가지 방법을 설명한다.





## 탐욕적 최선 우선 탐색(greedy best-first search)

탐욕적 최선 우선 검색은 목표에 가장 가까운 노드를 확장하면 해답에 빨리 도달할 가능성이 크다는 가정하에서 목표에 가장 가까운 노드를 선택한다.

f(n) = h(n)







## A* 탐색: 총 추정 해법 비용의 최소화

가장 널리 알려진 형태의 최선 우선 검색.

f(n) = g(n) + h(n)

이 탐색 방법은 노드에 도달하는 비용을 듯하는 g(n)과 노드에서 목표로 가는 비용을 뜻하는 h(n)을 결합해서 노드를 평가한다.

g(n)은 시작 노드에서 노드 n으로의 경로 비용을 돌려주므로, 그리고 h(n)은 n에서 목표로의 가장 싼 경로의 추정 비용이므로, 결국,

f(n) = n을 거쳐 가는 가장 싼 해답의 추정 비용

이다.

즉, 가장 싼 해답을 찾으려 한다면 제일 먼저 g(n) + h(n) 값이 제일 작은 노드를 찾는 것이 합리적이다. 이 전략이 단리 합리적인 것 이상임이 판명되었다. 발견법적 함수 h(n)이 특정 조건들을 만족한다고 할 때, A* 탐색은 완결성과 최적성을 모두 갖춘다. A* 알고리즘은 UNIFORM-COST-SEARCH와 같되, g 대신 g+h를 사용한다는 점이 다르다.





## 메모리 제한 발견법적 탐색

반복 심화 A*(iterative-deepening A*, IDA*)

재귀적 최선 우선 탐색(recursive best-first search, RBFS)

## 학습을 통한 탐색 향상

메타수준 학습(metalevel learning) 알고리즘 : 에이전트가 **학습**을 통해서 탐색을 더 개선할 수 있는 방법


# 발견법적 함수

발견법적 탐색 알고리즘의 성능은 발견법적 함수의 품질에 의존한다. 문제의 정의를 완화하거나, 부분 문제의 해답 비용들을 미리 계산해서 패턴 데이터베이스에 저장해 두거나, 문제 부류에 대한 경험으로부터 배움으로써 좋은 발견법적 함수를 구축할 수 있는 경우가 있다.

## 발견법적 함수의 정확성이 성능에 미치는 영향

## 완화된 문제로부터 허용 가능 발견법적 함수 생성

## 부분 문제로부터 허용 가능 발견법적 함수 생성: 패턴 데이터베이스

## 경험을 통한 발견법적 함수의 학습





# 요약


탐색 알고리즘 : 상태들과 동작들을 원자적으로 취급.

범용 Tree-search 알고리즘 : 모든 가능한 경로를 고려해서 해답을 찾는다.
범용 Graph-search 알고리즘 : 중복된 경로들의 고려를 피한다.

탐색 알고리즘의 품질을 판정하는 기준 : 완결성, 최적성, 시간 복잡도, 공간 복잡도. (복잡도는 상태 공간의 분기 계수 b와 가장 얕은 해답의 깊이 d에 의존한다.)

















