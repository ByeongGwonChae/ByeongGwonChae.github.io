---
title: "인공지능-04. 고급 탐색 기법"
category:
  - AI
tag:
  - AI
toc: true
toc_sticky: true
---

이번 장에서는 이전 장의 단순화 가정들을 완화해서 실세계에 좀 더 나아간다.

3장에서는 관찰 가능/결정론적/기지 환경을 가진, 그리고 해답이 하나의 동작열인 단일한 범주의 문제들만 논의했다. 이번 장에서는 그러한 가정들을 완화하면 어떻게 되는지 살펴본다.

우선 간단한 경우로 시작한다.

4.1과 4.2는 상태 공간 안에서 초기 상태로부터의 경로들을 체계적으로 탐색하는 대신 현재 상태 1~2개를 평가하고 수정하는 데 주력하는 국소 탐색(local search; 지역 탐색)만 수행하는 알고리즘들을 다룬다. 이런 알고리즘들은 해답 상태로 이어지는 경로 비용은 그리 중요하지 않고 해답 상태 자체만 중요한 문제에 적합하다. 국소 탐색 알고리즘에는 통계 물리학에서 영감을 얻은 알고리즘(모의 정련 등)과 진화 생물학에서 영감을 얻은 알고리즘(유전 알고리즘) 등이 포함된다.

4.3과 4.4에서는 결정론과 관찰 가능에 관한 가정들을 완화했을 때 생기는 일을 조사한다. 여기서 핵심은, 만일 에이전트가 자신이 받을 지각을 정확히 예측할 수 없다면, 그 지각들에 의해 드러날 각각의 우발 사건(contingency; 우발성)하에서 무엇을 수행해야 할지를 고려할 필요가 있다는 것이다. 관찰 가능성이 부분적이라면 에이전트는 자신이 처할 수 있는 상태들도 추적할 필요가 있다.

4.5는 초기에는 알려지지 않아서 반드시 탐색할 필요가 있는 상태 공간을 만난 에이전트에게 유용한 온라인 탐색(online search)을 탐구한다.

# 국소 탐색 알고리즘과 최적화 문제

3장에서 살펴본 탐색 알고리즘들은 탐색 공간을 체계적으로 탐색하도록 설계된 것이다. 그러한 체계성을 위해 알고리즘들은 메모리에 하나 이상의 경로를 유지하고 ,그 경로의 각 지점에서 어떤 대안들을 탐색했는지도 기록해 둔다. 목표를 성공적으로 찾았을 때 ,문제의 해답에는 그 목표로의 경로도 포함된다.

그러나 **목표로의 경로와 중요하지 않은 문제**도 많이 있다.

- 집적회로 설계
- 최적화
- 공장 설비 배치
- 주문생산 일정 수립(job-shop scheduling)
- 자동 프로그래밍
- 통신망 최적화
- 차량 노선 계획
- 포트폴리오 관리

등등 여러 주요 응용 분야에서 그러한 일반적인 속성이 성립한다.

목표로의 경로가 중요하지 않다면, 이전과는 달리 경로들을 전혀 신경 쓰지 않는 부류의 알고리즘들을 고려해 보아야 할 것이다. 국소 탐색(local search) 알고리즘들은 현재 노드(current node)만 사용하며(여러 개의 경로가 아니라), 일반적으로 오직 그 노드의 이웃 노드로만 이동하는 식으로 작동한다. 대부분의 경우 탐색 공정이 밟아 온 경로들은 메모리에 유지되지 않는다. 국소 탐색 알고리즘은 체계적이지는 않지만, 다음과 같은 2가지 중요한 장점을 가지고 있다.

1. 메모리를 아주 적게 소비한다. 보통은 고정된 양의 메모리만 사용한다.
1. 체계적 알고리즘은 적합하지 않은 커다란 또는 무한한 (연속)상태 공간에서도 적당한 해답을 찾아내는 경우가 많다.

국소 탐색 알고리즘은 목표를 찾는 것 외에 순수한 최적화 문제(optimization problem)를 푸는 데에도 유용하다. 최적화 문제는 목적 함수(objective function)를 기준으로 해서 가장 좋은 상태를 찾는 것이다. 최적화 문제 중에는 3장에 나온 '표준' 탐색 모형이 잘 맞지 않는 것들이 많다. 예를 들어 자연은 생식 적합성이라는 목적 함수를 제공한다. 즉, 다윈의 진화론은 일종의 최적화 문제를 풀려는 자연의 시도라 할 수 있다. 단, 이 문제에는 '목표 판정' 함수나 '경로 비용' 같은 것이 없다.

상태 공간 지형(state-space landscape)을 고려하면 국소 탐색의 이해에 도움이 된다. 이 지형은 '장소(location; 상태에 의해 정의됨)'와 고도(elevation; 발견법적 비용 함수나 목적 함수의 값에 의해 정의됨)가 있다. 고도가 비용에 해당한다면 문제의 목적은 가장 낮은 계곡, 즉 전역 최솟값(global minimum; 도는 전역 최소점)을 찾는 것이다. 고도가 목적 함수에 해당한다면 목적은 가장 높은 봉우리, 즉 전역 최댓값(global maximum; 또는 전역 최대점)을 찾는 것이다. (그냥 마이너스 기호만 삽입하면 이 둘을 상호 변환할 수 있다.) 국소 탐색 알고리즘들은 이러한 지형을 탐색한다. 완결적인(complete) 국소 탐색 알고리즘은 목표가 존재한다면 항상 목표를 찾아낸다. 최적 알고리즘은 항상 전역 최솟값/최댓값을 찾아낸다.








## 언덕 오르기 탐색

언덕 오르기(hill-climbing) 알고리즘

책의 4.2알고리즘은 언덕 오르기의 최고 경사 등반(steepest-ascent) 버전이다. 언덕 오르기 알고리즘은 값이 증가하는 방향으로, 즉 오르막으로 계속해서 이동하는 루프로 이루어진다. 루프는 주변에 더 큰 값이 없는 '정상(peak)'에 도달하면 종료된다. 알고리즘은 탐색 트리를 유지하지 않으므로, 현재 노드를 위한 자료구조는 상태와 목적 함수의 값만 담으면 된다. 언덕 오르기는 현재 상태에 바로 이웃한 값들만 고려할 뿐, 그 밖의 값들은 미리 살펴보지 않는다. 이는 기억상실증 환자가 짙은 안개 속에서 에베레스트 산의 정상에 오르려는 것과 비슷하다.

국소 탐색 알고리즘들은 완전 상태 형식화(complete-state formulation)를 사용한다.

다음에 어디로 갈지는 고려하지 않고 눈앞의 상황에서 가장 좋은 이웃을 선택한다는 점에서, 언덕 오르기를 탐욕적 국소 탐색(greedy local search)이라고 부르기도 한다.

언덕 오르기가 더 이상 진척이 없는 '곤경'에 빠지는 경우

- 극댓값(local maximum; 국소 최댓값) : 국댓값은 이웃 상태들보다는 높지만 전역 최댓값보다는 낮은 정상이다. 극댓값 근처에 도달한 언덕 오르기 알고리즘은 그 정상으로 올라가긴 하지만, 그때부터는 더 이상 오를 곳이 없게 된다. 
- 능석(ridge) : 능선은 극댓값들이 연이어 있는 상황에 해당한다. 탐욕적 알고리즘은 이런 상황을 통과하기가 아주 어렵다.
- 대지(plateau) : 대지는 상태 공간 지형에서 평평한 영역을 말한다. 대지는 오르막으로 가는 출구가 없는 평평한 극댓값이거나 진척이 가능한 어깨(shoulder)이다. 대지에서는 언덕 오르기 탐색이 길을 잃을 수 있다.

각 경우에서 알고리즘은 더 이상의 진척이 불가능한 지점에 다다르게 된다. 무작위로 생성된 8-퀸 상태에서 시작한 최고 경사 등반 언덕 오르기 알고리즘은 86%의 경우에 곤경에 빠진다. 문제사례를 푸는 경우는 14%밖에 되지 않는다. 진행은 빠르다. 성공의 경우 평균 4단계만에 해답을 찾으며, 곤경에 빠지는 경우는 평균 3단계이다. 상태 공간의 상태가 8<sup>8</sup> ≒ 1,700만 개라는 점을 생각하면 나쁘지 않은 성능이다.

4.2의 알고리즘은 최상의 후행자가 현재 상태와 같은 값인 대지에 도달하면 멈춘다. 대지가 사실은 어깨일 것이라는 희망을 품고 계속 나아가는 것이 좋지 않을까? 즉, 횡이동(sideway move)을 허용하는 것이 바람직하지 않을까? 답은 대체로 "예"이지만, 주의할 필요가 있다. 오르막 이동이 없을 때 횡이동을 허용한 경우 ,어깨가 아닌 평평한 극대점에 도달하면 알고리즘은 항상 무한 루프에 빠진다. 흔한 해결책 하나는 연속적인 횡이동 횟수에 제한을 두는 것이다. 예를 들어 8-퀸 문제에서는 이를 테면 횡이동을 연달아 100번까지만 할 수 있게 하는 등이다. 이렇게 하면 언덕 오르기의 문제 사례 해결 비율이 14%에서 94%로 올라간다. 그러나 성공에는 대가가 따른다. 알고리즘이 성공에 도달하는 데 걸리는 평균 단계 수가 약 21이고 실패로 가는 평균 단계 수는 64이다.

언덕 오르기의 여러 변형이 고안되었다.

확률론적 언덕 오르기(stochastic hill climbing) : 오르막 이동들 중 하나를 무작위로 선택한다.

선택의 확률은 오르막 이동의 경사(steepness)에 따라 달라질 수 있따. 이 변형은 대체로 최고 경사 등반 방식보다 느리게 수렴하지만, 상태 공간 지형에 따라서는 더 나은 해답을 찾아내기도 한다.

최초 선택 언덕 오르기(first-choice hill climbing) : 현재 상태보다 더 나은 후행자가 나올 때까지 후행자들을 무작위로 생성함으로써 확률론적 언덕 오르기를 구현한다. 이는 한 상태에 후행자가 많을 때(이를테면 수천 개) 좋은 전략이다.

지금까지 설명한 언덕 오르기 알고리즘들은 완결적이지 않다. 즉, 목표가 존재해도 극댓점에 빠져서 그 목표를 찾지 못하는 경우가 있다.

무작위 재시작 언덕 오르기(random-restart hill climbing) : 이 알고리즘은 "첫술에 배부르랴"라는 속담을 채용한다. 즉, 이 알고리즘은 목표를 찾을 때까지 초기 상태를 무작위로 생성해서 언덕 오르기 탐색을 여러 번 시도한다. 이 알고리즘이 완결적일 확률이 1에 접근함은 자명하다. 언젠가는 목표 상태와 일치하는 초기 상태가 생성될 것이기 때문이다. 각 언덕 오르기 탐색의 성공 확률이 p라고 하면, 필요한 재시작(반복) 횟수의 기댓값은 1/p이다. 횡이동을 허용하지 않은 8-퀸 문제 사례들에서 p≒0.14이다. 즉, 대략 7회 반복으로 목표를 찾을 수 있다(실패 6회, 성공 1회). 단계 수의 기댓값은 성공적인 한 반복의 비용에 (1-p)/p 곱하기 실패 비용을 더한 것으로, 대략 22이다. 횡이동을 허용햐면 평균............ 따라서 8-퀸 문제에서는 무작위 재시작 언덕 오르기가 실제로 아주 효과적이다. 퀸이 3백만 개인 문제에서도 이 접근방식은 해답을 1분 안에 찾아낸다.

언덕 오르기의 성공은 상태 공간 지형의 형태에 아주 크게 의존한다. 극댓값과 대지가 별로 없으면 무작위 재시작 언덕 오르기는 좋은 해답을 빠르게 찾아낸다. 반면 평평한 바닥에 고슴도치 가족이 넓게 흩어져 있고 각 고슴도치 가시 끝에 축소된 고슴도치가 얹혀 있는 패턴이 재귀적으로 무한히 반복되는 형태의 지형에서는 진짜 문제들이 많이 발생한다. 그렇긴 해도, 재시작을 몇 번(적은 수로) 하고 나면 비교적 좋은 극댓값을 찾게 되는 경우가 많다.

## 모의 정련

값이 낮은(or 비용이 높은) 상태로의 '내리막' 이동이 결코 없는 언덕 오르기 알고리즘은 극댓값에 머무를 수 있으므로 완결성을 보장하지 못한다. 반면 순수한 무작위 보행(random walk), 즉 일단의 후행자들 중 하나를 균등분포 난수로 선택하는 방식은 완결적이지만 극도로 비효율적이다. 이 점을 생각하면, 효율성과 완결성을 모두 제공하도록 언덕 오르기와 무작위 보행을 결합해 보는 것은 합당한 시도이다. 모의 정련(simulated annealing)이 바로 그러한 시도에서 나온 알고리즘의 하나이다. 

모의 정련을 설명하기 위해, 관점을 언덕 오르기에서 경사 하강(gradient descent)으로 바꾸기로 하겠다. 즉, 이제부터는 비용의 최소화 문제를 고려한다. .... 모의 정련 해법은 먼저 세게 흔드는 것으로 시작해서(즉, 높은 온도로 가열하고) 흔들기의 강도를 점차 감소한다(즉, 온도를 낮춘다).

모의 정련 알고리즘(4,5)의 제일 안쪽 루프는 언덕 오르기와 상당히 비슷하다. 그러나 최상의 이동을 선택하는 대신 무작위로 이동을 선택한다는 점이 다르다. 그 이동 때문에 상황이 나아지면 항상 그 이동을 채택한다. 상황이 나아지지 않으면 알고리즘은 1보다 낮은 확률로 그 이동을 채택한다. 그 확률은 이동의 '나쁨 정도(badness)'에 지수적으로 감소한다. 여기서 나쁨 정도란 상황 평가의 감소량을 말한다. .....

모의 정련 알고리즘은 원래 1980년대 초반에 VLSI 배치 문제를 푸는 데 많이 쓰였다. 이후 공장 일정 수립과 기타 대규모 최적화 과제에 널리 적용되었다. 




## 국소 다발 탐색

메모리에 노드 하나만 유지한다는 것이 메모리 제약 문제에 대한 극단적인 반응으로 보일 수 있따.

국소 다발 탐색(local beam search) :  하나가 아니라 k개의 상태를 추적한다. 이 알고리즘은 무작위로 생성한 상태 k개로 시작한다. 각 단계마다 k개의 모든 상태의 모든 후행자를 생성한다. 그 중 하나가 목표이면 알고리즘이 끝난다. 그렇지 않으면 전체 후행자 중 최상의 k개를 선택해서 같은 과정을 반복한다.

언뜻 보면 상태가 k개인 국소 다발 탐색이 그냥 k회의 무작위 재시작을 병렬로(차례로가 아니라) 실행하는 것과 다를 바가 없다고 생각할 수 있다. 그러나 두 알고리즘은 상당히 다르다. 무작위 재시작 탐색에서 각 탐색 공정은 석로 독립적으로 실행된다. **반면 국소 다발 탐색에서는 병렬적인 탐색 스레드들이 유용한 정보를 주고받는다.** 비유하자면, 최상의 후행자들을 생성한 상태들은 다른 상태들에게 "이리로 와, 이쪽 풀이 더 싱싱해!"라고 말해준다. 알고리즘은 실속 없는 탐색들을 빠르게 포기하고, 가장 큰 진척을 이를 수 잇는 쪽으로 자원을 이동한다.

가장 간단한 형태의 국소 다발 탐색은 k개의 상태들 사이의 다양성 부족 때문에 문제를 겪을 수 있다. k개의 상태들이 상태 공간의 작은 영역에 집중되기 쉬우며, 그러면 탐색은 언덕 오르기의 비싼 버전보다 별로 나을 바가 없게 된다. 확률론적 언덕 오르기와 같은 취지로 만들어진 **확률론적 다발 탐색(stochastic beam search)이라는 변형을 사용하면 이 문제가 완화된다. 확률론적 다발 탐색은 후보 후행자들 중 최상의 k개를 선택하는 것이 아니라 무작위로 k개를 선택하는데, 선택 확률은 해당 후행자의 값에 비례한다. '상체'(유기체)의 '후행자'(후손,자식)들이 자신의 '값'(적합성)에 기초한 확률로 다음 세대를 채운다는 점에서, 확률론적 다발 탐색은 자연선택 과정과 비슷한 면이 있다.







## 유전 알고리즘

유전 알고리즘(genentic algorithm, GA)은 확률론적 다발 탐색의 한 변형으로, 특징은 후행자 상태들이 한 상태의 수정에 의해서가 아니라 두 부모 상태의 결합에 의해 생성된다는 것이다. 자연선택의 비유는 확률론적 다발 탐색과 같되, 이제는 무성 생식이 아니라 유성 생식이 관여한다.



군집(population) : 무작위로 생성한 k개의 상태들의 집합
개체(individual) : 국집의 각 상태. 유한한 알파벳(문자 집합)의 한 문자열로 표현된다. 가장 흔히 쓰이는 방식은 0들과 1들로 이루어진 문자열(비트열)을 사용하는 것이다.

다음 세대 상태들의 생산 과정

1. 초기 군집
1. 적합도 함수 : 초기 군집의 상태들에 부여된 적합도 점수와 생식 확률 (=목적 함수)
1. 선택 : 그에 따라 결정된 생식 쌍들
1. 교차 : 탄생한 자식들
1. 돌연변이 : 자식들에 가해진 돌연변이

적합도 함수(fitness function; 또는 적응도 함수) : 목적 함수를 유전학의 용어로 부르는 말. 적합도 함수는 더 나은 상태에 대해 더 높은 값을 돌려주어야 한다.( ex)8-퀸 문제에서는 서로 공격하지 않는 퀸 쌍들의 개수를 적합도 함수로 사용하면 될 것이다.) 

교차점(crossover point)

돌연변이(mutation)

확률론적 다발 탐색처럼, 유전 알고리즘은 무작위 탐색을 동반한 오르막 이동 경향과 병렬 탐색 스레드들의 정보 교환을 결합한다. 유전 알고리즘의 주된 장점(이라고 할만한 것)은 교차 연산에서 비롯된다. 그러나, 만일 유전 코드의 위치들이 초기에 무작위 순서로 순열치환(permutation)된다면, 교차가 그 어떤 장점도 제공하지 못함을 수학적으로 증명할 수 있다. 직관적으로 본다면, 장점은 교차에 의해 문자들의 커다란 블록들을 결합함으로써 그 블록들이 유용한 기능을 수행하도록 개별적으로 진화시킨다는, 그럼으로써 탐색이 수행되는 수준의 입도(granularity; 세밀도)를 높인다는 점에서 비롯된다.

유전 알고리즘 이론은 알고리즘의 작동 방식을 스키마(schema)라는 개념을 애용해서 설명한다. 스키마는 문자를 구체적으로 지정하지 않은 자리들이 있는 부분 문자열이다.

스키마와 부합하는 문자열을 그 스키마의 **사례**(instance)라고 부른다. 스키마 사례들의 평균 적합도가 평균보다 높으면 시간이 지남에 따라 군집에서 그 스키마 사례들의 개수가 증가한다는 점이 밝혀졌다. 인접한 비트들이 서로 완전히 무관하다면 이러한 효과가 중요하지 않을 가능성이 확실히 크다. 왜냐하면, 그런 경우 일관된 이득을 제공하는 연속된 블록들이 몇 개 되지 않을 것이기 때문이다. 유전 알고리즘은 스키마들이 해답의 의미 있는 구성요소들에 해당할 때 가장 잘 작동한다. 예를 들어 전파 안테나를 유전 문자열로 표현한다고 할 때, 반사기(reflector)나 전향장치(deflector)에 해당하는 스키마들을 둘 수 있을 것이다. 좋은 구성요소는 서로 다른 다양한 설계들에서 유용할 가능성이 크다. 이는 유전 알고리즘을 성공적으로 사용하려면 표현을 셋미하게 처리할 필요가 있음을 말해 준다.

실제 응용에서 유전 알고리즘은 회로 배치나 주문생산 일정 수립 같은 최적화 문제에 광범위한 영향을 주었다. 현재로써는 유전 알고리즘의 매력이 그 성능에서 비롯되는지 아니면 진화론의 미학적으로 유쾌한 기원들에서 비롯되는지 확실하지 않다. 어떤 조건에서 어떤 유전 알고리즘이 좋은 성능을 내는지 식별하려면 아직 연구할 것이 많다.

# 연속 공간의 국소 탐색

지금까지 설명한 알고리즘 중 연속적인 상태와 동작 공간을 처리할 수 있는 것은 최초 선택 언덕 오르기와 모의 정련뿐이다. 그 외의 알고리즘은 연속 공간에서 분기 계수가 무한대이기 때문에 작동하지 않는다. 이번 절에서는 연속 공간에서 최적해를 찾는 몇 가지 국소 탐색 기법들을 아주 간략하게 소개한다. 이 기법들은 학습, 시각, 로봇 공학에 관련된 장들을 비롯한 이 책의 여러 곳에서 유용하게 쓰인다.

예제......

연속적 문제를 피하는 1가지 방법은 그냥 각 상태의 이웃을 이산화하는 것이다. 

지형의 **기울기(gradient)**를 이용해서 최댓값을 찾고자 하는 방법.

각 좌표를 조금 증가 또는 감소했을 때의 반응을 평가해서 소위 **실험적 기울기(empirical gradient)**를 계산하는 방법이 있다. 실험적 기울기 탐색은 상태 공간의 이산화된 버전에 대한 최고 경사 등반 언덕 오르기와 같다.

직선 탐색(line search)

뉴턴-랩슨법(Newton-Raphson method)

헤세 행렬(Hessian matrix)

차원 수가 더 높은 문제에서는 헤세 행렬의 성분 n<sup>2</sup>을 계싼하고 그 역을 구하는 비용이 클 수 있다. 그래서 연구자들은 뉴턴-랩슨법의 다양한 근사 버전을 개발했다.

연속 상태 공간에서도, 국소 탐색 방법들은 극댓값, 능선, 대지에 관련된 어려움을 이산 공간에서만큼이나 겪는다. 이에 대해 무작위 재시작과 모의 정련을 적용할 수 있으며, 그것이 도움이 되는 경우가 많다. 그러나 고차원 연속 공간은 아주 넓기 때문에 길을 잃기 쉽다.

마지막으로, 조금이라도 알아 두면 좋은 주제로 **제한된 최적화(constrained optimization)**가 있다. 해답들이 변수 값에 대한 어떤 엄격한 제약을 만족해야 하는 최적화 문제를 가리켜 제한된 최적화 문제라고 부른다.

제한된 최적화 문제의 난이도는 제약들의 성격과 목적 함수에 의존한다. 가장 잘 알려진 범주는 **선형 계획법(linear programming)** 문제로, 이 범주에서 제약들은 반드시 하나의 **볼록집합(convex set)을 형성하는 선형(일차) 부등식들이고 목적 함수도 선형이다. 선형 계획법의 시간 복잡도는 변수 개수에 대한 다항식이다.

최적화 문제 중 아마도 가장 널리 연구되며 가장 널리 적용되는 부류가 이 선형 계획법일 것이다. 선형 계획법은 좀 더 일반적인 **볼록 최적화(convex optimization)** 문제의 한 특수 경우이다. 볼록 최적화에서는 그 어떤 볼록 영역도 제한 영역이 될 수 있으며, 제한 영역 안에서 볼록함수인 그 어떤 함수도 목적 함수가 될 수 있다. 그런 조건들하에서 볼록 최적화 문제는 또한 다항식적으로 풀 수 있는, 그리고 변수가 수천 개인 경우에도 현실적으로 처리 가능한 문제이다. 기계 학습과 제어이론의 여러 주요 문제도 볼록 최적화 문제로 형식화할 수 있다.

# 비결정론적 동작들을 수반한 탐색

우발적 계획(contingency plan)
전략(strategy)

환경이 부분적으로 관찰 가능이거나 비결정론이면(또는 둘 다이면) 지각이 유용해진다. 부분 관찰 가능 환경에서 모든 지각은 에이전트가 처해 있을 수 있는 가능한 상태들의 집합을 좁히는 데 도움이 되며, 따라서 에이전트가 자신의 목표들을 달성하기가 더 쉬워진다. 환경이 비결정론적일 때 지각들은 동작을 수행했을 때 실제로 발생할 수 있는 결과들을 말해 준다. 두 경우 모두에서, 미래의 지각들을 미리 결정할 수는 없으며, 에이전트의 미래의 동작들은 그런 미래의 지각들에 의존하게 된다. 따라서 한 문제의 해답은 고정된 동작열이 아니라, 향후 받을 지각에 따라 어떤 동작을 수행할 것인지를 명시한 하나의 **우발적 계획(contingency plan)**이다. 이를 **전략(strategy)**이라고 부르기도 한다. 이번 절에서는 비결정론적 환경을 살펴본다.





## 변덕스러운 진공청소기 세계

3장의 문제들에 비결정론을 도입했을 때의 변화 :

동작 -> 3장의 전이 모형(transition model) 개념을 일반화할 필요가 있따. 전이 모형을 상태 하나만 돌려주는 RESULT 함수로 정의하는 대신, 가능한 결과 상태들의 집합을 돌려주는 RESULTS 함수를 사용하기로 한다. 예를 들어 변덕 진공 세계에서 상태 1에서의 Suck 동작은 집합 {5,7}의 한 상태로 이어진다. 즉, 오른쪽 칸의 먼지가 흡입될 수도 있고 아닐 수도 있다.
해답 -> 비결정론적 문제의 해답에는 중첩된 if-then-else 문들이 포함될 수 있다. 이는 그런 해답이 하나의 순차열이 아니라 트리 자료구조임을 뜻한다. 실제 물리적 세계의 문제 중에는 이런 우발성 문제가 많은데, 이는 정확한 예측이 불가능하기 때문이다. 걷거나 운전할 때 눈을 계속 뜨고 있는 사람들이 많은 이유도 바로 이것이다.

## AND-OR 탐색 트리

다음으로 해결해야 할 것은 비결정론적 문제에 대한 우발성 해답을 어떻게 찾아낼 것인가이다. 3장에서처럼 탐색 트리를 구축하는 것으로 시작한다. 단, 이번에는 트리의 특성이 다르다. 결정론적 환경에서 분기는 오직 각 상태에서의 에이전트 자신의 선택에 의해서만 일어난다. 그런 분기가 일어나는 노드를 **OR 노드**라고 부른다.

반면 비결정론적 환경에서 분기는 각 동작의 결과에 대한 환경의 선택에 의해서도 일어난다. 그런 노드를 **AND 노드**라고 부른다.

이 두 종류의 노드들이 번갈아 배치된 형태의 트리가 바로 **AND-OR 트리**이다.

- OR 노드 : 각 상태에서 에이전트 자신의 선택(동작)에 의해 일어나는 분기
- AND 노드 : 각 동작의 결과에 대한 환경의 선택에 의한 분기
- AND-OR 트리 : 두 종류의 노드들이 번갈아 배치된 형태의 트리

AND-OR 탐색 문제에 대한 해답

1. 모든 잎 노드에 목표 노드가 있고,
1. 모든 OR 노드에서 각각 하나의 동작을 명시하며,
1. 모든 AND 노드에 각각 모든 결과 가지가 포함되어 있는 하나의 부분 트리이다.

그림에서 굵은 선으로 표시된 것이 바로 그러한 해답 부분 트리이다.

이것은 4.3에 나온 계획에 해당한다. (그 계획은 if-the-else 구문을 이용해서 AND 가지들을 처리하지만, 한 노드에 가지가 셋 이상일 때에는 case 구문을 사용하는 것이 낫다.)

기본적인 문제 해결 에이전트를 이런 종류의 우발성 해답을 실행하도록 수정하는 것은 간단하다. 또한, 에이전트가 보장된 계획을 찾기 전에 행동할 수 있는, 그리고 일부 우발 사건들을 탐색 실행 도중 실제로 그 우발 사건이 발생한 경우에만 처리할 수 있는 다른 방식의 에이전트 설계도 고려할 수 있다. 탐색과 실행을 그런 식으로 **교대 적용(interleaving)**하는 방식은 탐험 문제와 게임 플레이에도 유용하다.

도해 4.1 : and-or 그래프 탐색을 위한 재귀적인 깊이 우선 알고리즘

이 알고리즘의 핵심 특징 하나는 비결정론적 문제에서 자주 발생하는(이를 테면 어떤 동작에 아무 효과도 없거나, 의도하지 않은 효과를 교정할 수 있는 경우에서) 순환 주기(cycle)를 처리하는 방식이다. 현재 상태가 뿌리 노드에서 시작된 경로의 한 상태와 동일하면 이 알고리즘은 실패를 돌려준다. 이것이 현재 상태에서 해답이 **없음**을 뜻하는 것은 아니다. 단지 만일 비순환 해답이 존재한다면 현재 상태의 이전 출현에서 그 해답에 도달할 수 있어야 하므로 현재 출현은 폐기할 수 있음을 뜻할 뿐이다. 이러한 점검 덕분에 알고리즘이 모든 유한 상태 공간에서 반드시 종료됨을 보장할 수 있다. 모든 경로는 반드시 목표나 막다른 골목, 또는 반복된 상태에 도달하기 때문이다. 이 알고리즘이 현재 상태가 뿌리로부터의 **다른** 경로에 있는 한 상태의 반복임을 점검하지는 않음을 주목하기 바란다. 이는 효율성을 위해 중요한 문제이다.

AND-OR 그래프를 너비 우선이나 최선 우선 방법으로 탐색할 수 있다. 동작열이 아니라 우발성 해답의 비용을 추정하도록 발견법적 함수의 개념을 수정해야 하겠지만 허용 가능성 개념은 그대로 적용되며, 최적해를 찾는 A* 알고리즘에 상응하는 알고리즘도 존재한다. 좀 더 알고 싶은 독자는 이번 장 끝의 참고문헌을 보기 바란다.



## 반복 시도

순환 해답(cyclic solution) : 특정 행동을 성공할 때까지 반복해서 시도

계획의 일부에 이름표(label)를 부여하고 나중에 그 이름표를 활용할 수 있게(계획 자체를 반복하지 않고) 한다면 그런 순환 해답을 표현할 수 있다. 다음은 그러한 이름표를 이용해서 표현한 순환 해답이다.

....

일반적으로 순환 계획은, 모든 잎 노드가 목표 상태이고 계획의 모든 지점에서 하나의 잎에 도달할 수 있따면 해답으로 간주할 수 있다. AND-OR-GRAPH-SEARCH를 어떻게 수정해야 하는지는 연습문제 4.6에서 다룬다. 여기서 반드시 깨달아야 할 점은, 상태 공간에서 상태 L로 돌아가는 루프는 계획에서 상태 L에 대한 부분 계획이 실행되는 지점으로 돌아가는 루프에 해당한다는 것이다.

순환 해답의 정의가 주어졌을 때, 그러한 해답을 실행하는 에이전트는 언젠가는 목표에 도달하게 된다. 단, 여기에는 비결정론적 동작의 모든 결과가 언젠가는 발생한다는 가정이 깔려 있다. 그러한 가정이 합당할까? .... 이런 경정은 초기의 문제 형식화(관찰 가능, 비결정론)를 폐기하고 대신 키의 관찰 불가능한 속성 때문에 실패가 일어날 수 있는 다른 형식화(부분 관찰 가능, 결정론)를 채택하는 것으로 이해할 수 있겠다. 이 문제에 대해서는 13장에서 좀 더 이야기한다.

# 부분 관찰 가능 환경의 탐색

이번에는 부분 관찰 가능성의 문제를 살펴보자. 이 경우 에이전트의 지각들만으로는 정확한 상태를 결정할 수 없다. 이전 절의 도입부에서 언급했듯이, 만일 에이전트가 여러 가능한 상태 중 하나에 있다면, 비록 환경이 결정론적이라고 해도 하나의 동작은 여러 가능한 결과 중 하나로 이어진다. 이런 부분 관찰 가능 환경 문제를 푸는 데 필요한 핵심 개발은 **믿음 상태(belief state)**이다. 믿음 상태는 현재 시점까지의 동작열들과 지각들이 주어졌을 때 에이전트가 현재 처한 가능한 물리적 상태들에 관한 에이전트 자신의 믿음을 나타낸다. 이번 절에서는 우선 믿음 상태의 연구를 위한 가장 간단한 시나리오에 해당하는, 에이전트에 감지기가 전혀 없는 상황을 살펴본다. 그런 다음에는 부분적인 감지 능력과 비결정론적 동작들을 추가한다.

## 관찰 없는 탐색

무감지기(sensorless) 문제 또는 순응(conformant) 문제 : 에이전트의 지각들이 아무런 정보도 제공하지 않는 문제

무감지기 에이전트는 자신이 어떤 상태에 있는지 알지 못하므로 문제를 풀 가망이 없다고 생각하는 독자도 있을 것이다. 그러나 무감지기 문제를 풀 수 있는 경우가 꽤 많다. 게다가 무감지기 에이전트가 놀랄 만큼 유용할 수 있는데, 기본적으로 이는 그런 에이전트들이 감지기에 의존하지 않고도 제대로 작동할 수 있기 때문이다. 예를 들어.... 감지에 비용이 많이 든다는 점도 감지를 피하는 또 다른 이유이다. 예를 들어.... 

강제(coercion)할 수 있다

무감지 문제를 풀 때는 물리적 상태가 아니라 믿음 상태들의 공간을 탐색한다. 믿음 상태 공간에서 문제는 완전 관찰 가능임을 주목하기 바란다. 에이전트는 항상 자신의 믿음 상태를 알고 있기 때문이다. 더 나아가서, 해답은(있다면) 항상 하나의 동작열이다. 이는, 3장에서 나온 보통의 문제에서처럼, 각 동작 이후 받을 지각들을 완전히 예측할 수 있기 때문이다. 지각들의 집합은 항상 공집합니다! 따라서 계획해야 할 우발 사건은 존재하지 않는다. 이는 환경이 비결정론적이라도 참이다.

이러한 개선안을 적용한다고 해도,



예측(prediction) : 동작 수행 이후 새 믿음 상태를 생성하는 공정

점진적 믿음 상태 탐색(incremental belief-state search)


## 관찰 있는 탐색

일반적으로 부분 관찰 가능 문제에서는 환경이 에이전트를 위해 지각들을 싱성하는 방식을 정의해야 한다.

형식적인 문제 명세에는 주어진 상태에서 받은 지각을 돌려주는 PERCEPT(s) 함수가 포함된다.(감지가 비결정론적일 때에는 가능한 지각들의 집합을 돌려주는 PERCEPTS 함수를 사용한다.)

...

관찰이 부분적으로만 가능할 때에는 주어진 하나의 지각을 산출하는 상태가 여러 개인 경우가 많다.

...

그러나 전이 모형은 다소 복잡하다. 특정 동작에 의한 한 믿음 상태에서 다음 믿음 상태로의 전이가 다음과 같은 세 시기(state)로 발생한다고 생각할 수 있다.

예측(prediction)
관찰 예측(observation prediction)
갱신(update)

........

## 부분 관찰 기능 문제 풀기






## 부분 관찰 가능 환경을 위한 에이전트

감시(monitoring)
필터링(filtering)
상태 추정(state estimation)
재귀적 상태 추정기(recursive state estimator)


위치 결정(localization) 과제

# 온라인 탐색 에이전트와 미지 환경

온라인 탐색 : 계산과 동작을 교대로 실행한다(interleave).

## 온라인 탐색 문제

대항 논점(adversary argument)
안전 탐험 가능

## 온라인 탐색 에이전트

## 온라인 국소 탐색

## 온라인 탐색의 학습












# 요약

'고전적' 사례에서 벗어난 문제들을 위한 탐색 알고리즘들

언덕 오르기 같은 국소 탐색 방법들은 완전 상태 형식화에 대해 작동하며, 메모리에서 적은 수의 노드들만 유지한다. 여러 가지 확률론적 아록리즘들이 개발되었는데, 그 중 모의 정련은 적절한 냉각 일정이 주어진다면 최적해를 돌려준다.

여러 국소 탐색 방법들은 연속 공간의 문제들에도 적용된다. 선형 계획법과 볼록 최적화 문제에서는 상태 공간의 형태와 목적 함수의 성격에 일정한 제양이 따른다. 그런 문제들에서는 실제 으용ㅇ에서 극도로 효율적인 경우가 많은 다항식 시간 알고리즘이 가능하다.

유전 알고리즘 : 많은 수의 상태들로 이루어진 군집이 유지되는 환경에 대한 확률론적 언덕 오르기 탐색 알고리즘. 새 상태는 변이와 교차에 의해 생성되는데, 교차는 군집의 두 상태의 쌍을 결합하는 효과를 낸다.

비결정론적 환경에서 에이전트는 AND-OR 탐색을 수행해서, 실행 도중 어떤 결과가 발생하더라도 목표에 도달할 수 있는 우발적 계획을 생성할 수 있다.

부분 관찰 가능 환경에서 믿음 상태는 에이전트가 처할 수 있는 일단의 상태들을 나타낸다.

표준 탐색 알고리즘을 믿음 상태 공간에 직접 적용해서 무감지기 문제를 풀 수 있으며, 믿음 상태 AND-OR 탐색으로는 일반적인 부분 관찰 가능 문제를 풀 수 있다. 믿음 상태 안에서 해답을 상태별로 구축하는 점진적 알고리즘이 더 효율적인 경우가 많다.

탐험 문제는 환경에 어떤 상태들이 있고 어떤 동작이 가능한지를 에이전트가 전혀 알지 못하는 상황에서 발생한다. 안전하게 탐험할 수 잇는 환경에서 온라인 탐색 에이전트는 지도를 구축하고 목표를 찾을 수 있다(목표가 있다고 할 때). 경험에 의거한 발견법적 추정치의 갱신은 극솟값을 탈출하는 효과적인 방법이 된다.

