---
title: "인공지능-03. 검색"
category:
  - AI
tag:
  - AI
toc: true
toc_sticky: true
---

에이전트가 결정론적이고 관찰 가능하며 정적이로 완전히 알려진 환경 안에서 동작을 선택할 때 사용할 만한 방법들.

이러한 환경에서 에이전트는 자신의 목표를 달성할 수 있는 일련의 동작들을 구축한다. 그러한 공정을 가리켜 검색이라고 부른다.





검색 알고리즘 : 상태들과 동작들을 원자적으로 취급.

범용 Tree-search 알고리즘 : 모든 가능한 경로를 고려해서 해답을 찾는다.
범용 Graph-search 알고리즘 : 중복된 경로들의 고려를 피한다.

검색 알고리즘의 품질을 판정하는 기준 : 완결성, 최적성, 시간 복잡도, 공간 복잡도. (복잡도는 상태 공간의 분기 계수 b와 가장 얕은 해답의 깊이 d에 의존한다.)



# 문제 해결 에이전트



문제의 5가지 요소

1. 초기 상태(initial state) - 에이전트가 처음 시작하는 상태.
1. 동작 - 에이전트가 할 수 있는 동작들의 서술.
1. 전이 모형(transition model) - 각 동작의 결과를 서술.
1. 목표 판정(goal test) 함수 - 주어진 상태가 목표 상태인지 판정
1. 경로 비용(path cost) 함수 - 각 경로에 수치 비용을 배정한다.

문제의 환경 : 하나의 상태 공간

문제의 해답 : 상태 공간 안에서 초기 상태에서 목표 상태로 가는 경로


# 문제의 예

문제의 형식화하는 단계

장남감 문제(toy problem) : 다양한 문제 해결 방법의 이해 또는 연습을 목적으로 한 것. 간결하고 정확하게 서술할 수 있기 때문에 서로 다른 연구자들이 알고리즘의 성능을 비교하는데 유용하다.

- 진공청소기 세계
- 8-퍼즐(8-puzzle)
- 볼록 밀기 퍼즐(sliding-block puzzle)
- 8-퀸 문제(8-queens problem)

실세계 문제(real-world problem) : 사람들이 그 해답을 실제로 원하고 요구하는 문제들. 이런 문제들은 모두가 동의하는 한 가지 방식으로 서술하기 힘든 경우가 많은데, 아래에 나온 서술에서 적어도 해당 형식화들의 전반적인 상을 파악할 수는 있을 것이다.

- 노선 찾기 문제(route-finding problem)
- 순회 문제(touring problem)
- 순회 판매원 문제(traveling salesperson problem, TSP)
- VLSI 배치(layout) 문제
- 로봇 내비게이션(robot navigation)
- 자동 조립 시퀀싱(automatic assembly sequencing)
- 단백질 설계(protein desing)

# 해답의 검색

문제를 푸는 단계

검색 트리(search tree)를 형성.


## 검색 알고리즘의 기반구조



## 문제 해결 성능 측정

알고리즘의 성능은 다음 4가지로 평가할 수 있다.

1. 완결성 : 문제에 해답이 존재할 때 알고리즘이 해답을 반드시 찾아내는가?
1. 최적성 : 검색 전략이 최적해를 찾아내는가?
1. 시간 복잡도 : 해답을 찾는데 얼마나 시간이 걸리는가?
1. 공간 복잡도 : 검색을 수행하는데 메모리가 얼마나 필요한가?

# 정보 없는 검색 전략

정보 없는 검색(uniformed search) 또는 맹목적 검색(blind search)

이 부류의 전략들은 상태에 관해 문제 정의에 주어진 것 이상의 정보를 제공받지 못하는 상황을 위한 것이다. 그런 상황에서 할 수 있는 일은 후행자들을 생성하고 목표 상태와 비목표 상태를 구분하는 것뿐이다.





정보 없는 검색 방법 : 문제의 정의에만 접근할 수 있다.

- 너비 우선 검색 : 가장 얕은 노드를 먼저 확장한다. 이 알고리즘은 완결적이고, 단계 비용이 일정할 때 최적이지만, 공간 복잡도가 지수적이다.
- 균일 비용 검색 : 경로 비용이 가장 낮은 노드를 확장한다. 이 알고리즘은 일반적인 단계 비용들에 대해 최적이다.
- 깊이 우선 검색 : 아직 확장되지 않은 가장 깊은 노드를 먼저 확장한다. 이 알고리즘은 완결적이지도 않고 최적도 아니지만, 공간 복잡도가 선형이다. 깊이 제한 검색은 여기에 깊이 한계를 추가한다.
- 반복 심화 검색 : 목표가 나올 때까지 깊이 한계를 증가하면서 깊이 우선 검색을 호출한다. 이 알고리즘은 완결적이고, 단계 비용이 일정할 때 최적이며, 시간 복잡도는 너비 우선 검색과 비슷하다. 그리고 공간 복잡도는 선형이다.
- 양방향 검색 : 시간 복잡도를 크게 줄일 수 있지만 항상 적용할 수 있는 것은 아니며, 공간이 너무 많이 필요할 수 있다.

## 너비 우선 검색(breadth-first search) 

뿌리 노드를 먼저 확장하고, 뿌리 노드의 모든 후행자를 확장하고, 그 후행자들의 후행자들을 확장하는 식으로 진행하는 간단한 전략. 일반화하자면, 검색 트리의 임의의 깊이에서 그 깊이에 있는 모든 노드가 확장된 후에야 그 다음 수준의 노드들이 확장된다.

## 균일 비용 검색(uniform-cost search)

## 깊이 우선 검색(depth-first search)

## 깊이 제한 검색(depth-limited search)

## 반복 심화 깊이 우선 검색(iterative deepening search)

## 반복적 연장 검색(lengthening search)

## 양방향 검색(bidirectional search)

## 정보 없는 검색 전략들의 비교




# 정보 있는(발견법적) 검색 전략들

정보 있는 검색(informed search) 또는 발견법적 검색(heuristic search)

정보 있는 검색 방법 : n에서 해답으로의 비용을 추정하는 발견법적 함수에 접근할 수 있다.

- 일반적인 최선 우선 검색 알고리즘 : 평가 함수에 기초해서 노드를 선택한다.
- 탐욕적 최선 우선 검색 : h(n)이 최소인 노드들을 확장한다. 이 알고리즘은 최적은 아니나, 효율적인 경우가 많다.
- A* 검색 : f(n) = g(n) + h(n)이 최소인 노드들을 확장한다. h(n)이 허용 가능이거나(Tree-search의 경우) 일관적일 때(Graph-search의 경우) 완결적이고 최적이다. 공간복잡도는 여전히 비실용적이다.
- RBFS(재귀적 최선 우선 검색) 과 SMA*(단순화된 메모리 제한 검색) : 안정적이고 최적성을 갖춘 검색 알고리즘. 제한된 양의 메모리를 사용한다는 특징이 있다. 시간이 충분히 주어진다면 이 알고리즘들은 A*가 메모리 부족 때문에 풀지 못하는 문제들을 풀 수 있다.



## 탐욕적 최선 우선 검색(greedy best-first search)

## A* 검색: 총 추정 해법 비용의 최소화

## 메모리 제한 발견법적 검색

반복 심화 A*(iterative-deepening A*, IDA*)

재귀적 최선 우선 검색(recursive best-first search, RBFS)

## 학습을 통한 검색 향상

메타수준 학습(metalevel learning) 알고리즘


# 발견법적 함수

발견법적 검색 알고리즘의 성능은 발견법적 함수의 품질에 의존한다. 문제의 정의를 완화하거나, 부분 문제의 해답 비용들을 미리 계산해서 패턴 데이터베이스에 저장해 두거나, 문제 부류에 대한 경험으로부터 배움으로써 좋은 발견법적 함수를 구축할 수 있는 경우가 있다.

## 발견법적 함수의 정확성이 성능에 미치는 영향

## 완화된 문제로부터 허용 가능 발견법적 함수 생성

## 부분 문제로부터 허용 가능 발견법적 함수 생성: 패턴 데이터베이스

## 경험을 통한 발견법적 함수의 학습






















